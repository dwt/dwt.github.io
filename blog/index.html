
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="../static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/pygments.css">
    <title>Blog</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin H√§ckers Blog Artikel" href="feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="../" class="navbar-brand ">üè†</a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="../work/" class="nav-link">Professionelle Softwareentwicklung</a></li>
    
      <li class="nav-item "><a href="../projects/" class="nav-link">Projekte</a></li>
    
      <li class="nav-item "><a href="../publications/" class="nav-link">Ver√∂ffentlichungen und Vortr√§ge</a></li>
    
      <li class="nav-item active"><a href="./" class="nav-link">Blog<span class="sr-only">(ausgew√§hlt)</span></a></li>
    
      <li class="nav-item "><a href="../categories/" class="nav-link">Kategorien</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="./">üá©üá™</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="../en/blog/">üá¨üáß</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

  

<a class="breadcrumb-item " href="../">üè†</a>


<a class="breadcrumb-item active" href="./">Blog</a>

</nav>
    </header>
    <article class="page blog  container-fluid">
      
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/2/die-freuden-einer-gut-eingerichteten-shell/">
        Die Freuden einer gut eingerichteten Shell
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2025-02-27">Donnerstag, 27. Februar 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2025/2/die-freuden-einer-gut-eingerichteten-shell/terminal.jpg" alt="Terminal"></p>
<p>Es f√§ngt nat√ºrlich mit der Frage an: welche Shell?</p>
<p>Das ist sehr einfach zu beantworten. Auf MacOS ist die <a href="https://www.zsh.org">zsh</a> die Standard-Shell - und daher sollte man die auch benutzen. Artikel Fertig, vielen Dank f√ºrs Lesen! üòÖ</p>
<p>Windows hat die <a href="https://de.wikipedia.org/wiki/PowerShell">PowerShell</a> - wer damit Arbeiten (muss) sollte sie lernen!</p>
<p>Die nackte Shell ist ziemlich schlecht konfiguriert, da die m√∂glichkeiten der Shell gar nicht ausgenutzt werden. Auf Linux-Distributionen ist es Standard, das die Shell von der Distribution eingerichtet wird, daher kann man damit meistens schon gut arbeiten.</p>
<p>Aber f√ºr MacOS (und Windows) gibt es aber viel zu tun.</p>
<p>So sieht die zsh unkonfiguriert aus:</p>
<div class="hll"><pre><span></span>dwt@NB1321<span class="w"> </span>~<span class="w"> </span>%<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>Library/Favorites
dwt@NB1321<span class="w"> </span>Favorites<span class="w"> </span>%
</pre></div>
<p>Das ist schon gar nicht schlecht, denn man sieht einiges:</p>
<ul>
<li>Welcher Nutzer ist man gerade. Wichtig, wenn man viel mit <code>sudo</code> arbeitet, damit man nicht versehentlich Kommandos als <code>root</code> mit zu vielne Rechtena usf√ºhrt.</li>
<li>Auf welchem Rechner ist man gerade eingeloggt. Wichtig wenn man auf vielen Rechnern arbeitet und nicht</li>
<li>Den aktuellen Ordner in dem man ist (<code>Favorites</code>). Wichtig damit man z.B. nicht versehentlich die falschen Dateien l√∂scht.</li>
<li>Der Prompt <code>%</code> trennt die Meta-Informationen von dem was man selbst eingibt.</li>
</ul>
<p>Da geht aber noch wesentlich mehr. Bei mir z.B. sieht der Prompt so aus:</p>
<div class="hll"><pre><span></span>~/C/P/m/api<span class="w"> </span>‚ùÑÔ∏è<span class="w"> </span>üß™<span class="w"> </span>nix-shell-env<span class="w">   </span>üêç<span class="w"> </span>venv<span class="w"> </span>‚õµÔ∏è<span class="w"> </span>mkk-itsc-dev<span class="w"> </span><span class="o">(</span>api<span class="o">)</span><span class="w"> </span>üå±<span class="w"> </span>main<span class="w"> </span><span class="nv">$!</span><span class="w">  </span>4s
‚ùØ
</pre></div>
<p>Da ist enthalten:</p>
<ul>
<li><code>~/C/P/m/api</code> - nicht nur der aktuelle Ordner, sondern auch jeweils der Anfangsbuchstabe der dar√ºber liegenden Ordner. Das liefert platzsparend viel mehr Kontext, wo man gerade ist. Super wenn man in vielen Projekten gleichnamige Ordner wie z.B. <code>etc</code>, <code>src</code> oder <code>dist</code> hat.</li>
<li><code>‚ùÑÔ∏è üß™ nix-shell-env</code> Zeigt an, dass gerade eine 'dreckige' <a href="https://nixos.wiki/wiki/Development_environment_with_nix-shell">Nix-Shell</a> aktiv ist. Das verwende ich um Projeket-Spezifische Abh√§ngigkeiten (Shell-Tools, bestimmte Vesionen von Python etc.) zu installieren die ich deklarativ im Projekt tracke. Gut vergleichbar mit Python-Virtual-Envs - aber eben f√ºr alles, nicht nur Python-Pakete. Dreckig ('impure') ist Sie, da nicht <em>nur</em> die Shell-Tools aus der Nix-Shell sichtbar sind, sondern auch alles andere was ich im Betriebsystem installiert habe.</li>
<li><code>üêç venv</code> - zeigt an, dass gerade ein Python-Virtual-Env aktiv ist. Da ich haupts√§chlich mit Pyton entwickle ist das nat√ºrlich entscheidend weil es bedeutet das ich die Projekt-Werkzeuge direkt verwenden kann, da sie im <code>$PATH</code> und <code>$PYTHONPATH</code> sind.</li>
<li><code>‚õµÔ∏è mkk-itsc-dev (api)</code> zeigt an, dass ich mit dem <code>mkk-itsc-dev</code> Kubernetes Cluster verbunden bin, und den Namespace <code>api</code> aktiviert habe. Das ist mir sehr wichtig, damit ich nicht versehentlich mit <code>kubectl</code> Befehlen versehentlich den Produktiv-Cluster zerst√∂re. (Rate wieso mir das so wichtig ist‚Ä¶)</li>
<li><code>üå± main $!</code> zeigt an, dass ich in einem Git-Repository bin, auf dem main branch, das ich dinge ge-'stash't habe (die vergisst man sonst sehr leicht) und das ich √Ñnderungen habe die ich noch nicht commited habe. Hier gibt es <a href="https://starship.rs/config/#git-status">auch noch mehr informationen wenn das Repo den entsprechenden Zustand hat</a>.</li>
<li>Zuletzt sehe ich da das letzte Kommando 4 Sekunden gedauert hat. Das wird nur angezeigt wenn das letzte Programm mehr als 3 Sekunden gedauert hat und ist immer wiede ein hilfreiche Information um bei langlaufenden Prozesen zu verstehen ob es sich lohnt da etwas zu optimieren.</li>
</ul>
<p>Nat√ºrlich k√∂nnte man hier noch viel mehr anzeigen, je nachdem an was man gerade arbeitet. Ich habe hier eben die Informationen aufgenommen die ich am meisten ben√∂tige.</p>
<p>Jetzt kommt der Clou: Fr√ºher habe ich das alles von hand Konfiguriert. Das war ein ewiges und m√ºhsammes gefummel um <code>$PS1</code> und konsorten so hinzufummeln das das alles funktioniert hat, und hat nie Spa√ü gemacht. Der Standard ist derzeit, das man einen Shell-Konfigurations-Framework wie <a href="https://ohmyz.sh">Oh-My-Zsh</a> oder <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> verwendet. Und die sind auch gut. Aber auch langsam, und komplex und kompliziert. Wenn man da mal etwas anders haben will dann gott bewahre wenn das nicht schon vorbereitet ist oder man darf sich nicht nur mit den Komplexit√§ten von <code>$PS1</code> auseinander setzen, sondern auch noch damit wie genau dieser Framework das handhabt.</p>
<p>Inzwische bin ich weiser geworden, und verwende <a href="https://starship.rs">Starship</a>. Damit kann ich meinen Prompt deklarativ in einer <code>.toml</code> Datei konfigurieren und diesen auch mitnehmen wenn ich mal die Shell Wechsle. (Was h√§ufiger vorkommt als mir lieb ist).</p>
<p><a href="2025/2/die-freuden-einer-gut-eingerichteten-shell/starship.toml">So sieht meine Konfiguration aus</a></p>
<p>Wie richtet man das ein?</p>
<ol>
<li><code>brew install starship</code> (oder mit <a href="https://lix.systems">nix</a>)</li>
<li><code>nano ~/.zshrc</code> und am Ende <code>eval "$(starship init zsh)"</code> einf√ºgen.</li>
<li>Konfigurationsdatei erstellen: <code>nano ~/.config/starship.toml</code> und z.b. <a href="2025/2/die-freuden-einer-gut-eingerichteten-shell/starship.toml">den Inhalt aus der Datei oben einf√ºgen</a>.</li>
<li>Shell neu starten oder neues Terminal √∂ffnen.</li>
</ol>
<p>Danke sagen f√ºr die grandiose Verbesserung eures Shell-Lebens bei mir nicht vergessen. üòÖ</p>

    </section>
    
      <footer>
        <a href="2025/2/die-freuden-einer-gut-eingerichteten-shell/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/">
        A Nix&#39;le in a B√ºchse und a goldigs Warteweile
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2025-02-08">Samstag, 8. Februar 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/nix-rabbit-hole.png" alt="Das Nix Hasenloch">
‚Ä¶ ist ein schw√§bisches Sprichwort und passt gar nicht so schlecht f√ºr die vielen schlechten Wortwitze die sich automatisch ergeben, wenn man anf√§ngt, sich in das <a href="https://nix.dev">Nix Projekt</a> einzuarbeiten.</p>
<p>Zun√§chst mal die Karotte mit der ich mich k√∂dern lie√ü:</p>
<ul>
<li>Deklarative Konfiguration von Software-Builds, System-Konfigurationen, und wenn man m√∂chte auch Deployments z.B. in Kubernetes und was man sonst gerne m√∂chte</li>
<li>Ein funktionaler Paket-Manager, das hei√üt: Jede Software kann ihre eigenen Abh√§ngigkeiten in der passenden Version haben. Wenn ich mal ein Tool in der Version von vor 10 Jahren brauche - einfach zus√§tzlich installieren, ohne dass dadurch etwas gest√∂rt wird. Wenn ich mal eine neuere Version von etwas brauche als die aktuelle Distribution anbietet: Einfach installieren, ohne dass dadurch etwas gest√∂rt wird.</li>
<li>Rollback: Systemkonfiguration hat etwas kaputt gemacht? Einfach R√ºckg√§ngig machen.</li>
<li>Update auf eine neue Version des Betriebssystems: Man kriegt fehlermeldungen f√ºr alle Konfigurationen die man vorgenommen hat die jetzt umbenannt wurden oder anders funktionieren. ü§Ø</li>
<li>Reproduzierbarkeit: Vollst√§ndige Erfassung der Inputs und Ablegen derselben in einem Lock-File.</li>
<li>Eine riesige Community, die beste Praktiken zum Betrieb von Linux (und mehr) Systemen <a href="https://repology.org/repositories/statistics/total">in die gr√∂√üte Software-Bibliothek kodiert, die wir bisher gesehen haben.</a></li>
</ul>
<p>Was sollte man da nicht m√∂gen?</p>
<p>Auf MacOs gibt es mit <a href="https://github.com/LnL7/nix-darwin">nix-darwin</a> ein Projekt mit dem man die System-Konfiguration deklarativ vornehmen kann - und auch <a href="https://brew.sh">homebrew</a> (was sonst so gut wie gar nicht reproduzierbar ist) unter Kontrolle kriegt. Und wenn man m√∂chte, verwaltet es einem auch die dotfiles.</p>
<p>Es gibt allerdings einen gewaltigen Nachteil: Das Ganze ist echt komplex und kompliziert. Und die Dokumentation ist nicht schlecht, aber k√∂nnte deutlich besser sein.</p>
<p>Wenn man diese H√ºrde √ºberwindet, wird man mit einer erstaunlich kompakten und sehr schnell anzuwendenden System-Konfiguration belohnt. Damit kann man zum Beispiel auf einem Mac ein vollst√§ndig konfiguriertes System-Image f√ºr einen Raspberry Pi erstellen. Dann noch flaschen, starten und l√§uft! Oder auf meinem Mac Bauen, und via ssh auf dem RasPi deployen, ohne dort irgendwas zu machen was dessen CPU stresst.</p>
<p>Ich habe inzwischen angefangen, meine Rechner damit zu verwalten und konfigurieren.</p>
<ul>
<li><a href="https://github.com/dwt/nix-darwin-config">Mein Rechner (nix-darwin)</a></li>
<li><a href="https://github.com/dwt/home-servers">Mein Homelab (nixos)</a></li>
<li><a href="https://github.com/dwt/home-automation">Meine Heimautomatisierung (python)</a></li>
</ul>
<h1>Nix ist vielleicht nichts f√ºr dich‚Ä¶</h1>
<p>‚Ä¶ aber wenn Du ein bisschen nerdig bist, und gerne auf der Kommandozeile lebst, infrastruktur as Code magst oder lernen magst und DevOps f√ºr dich eh normal ist. Dann k√∂nnte Nix auch f√ºr dich genau das richtige sein.</p>
<h1>Wie lernt man Nix am besten?</h1>
<p>Was mir beim Lernen von Nix gefehlt hat, w√§re eine Leitlinie gewesen, in welcher Reihenfolge ich mich an die vielen Features von Nix heran tasten sollte. Eine Reihenfolge, die sicherstellt, das die Lernkurve zu jedem Zeitpunkt ertr√§glich bleibt. Und besonders wichtig: Die Sicherstellt, das zu jedem Zeitpunkt sichtbar ist wie cool und wertvoll diese Technologie ist. Sonst l√§uft man Gefahr, ob der steilen Lernkurve abzuspringen.</p>
<p>Das h√§tte ich gerne gehabt: Wenn du anf√§ngst Nix zu lernen, dann am besten in dieser Reihenfolge:</p>
<h2>1. Schritt: Installieren, ohne was bestehendes kaputt zu machen</h2>
<p>Zuerst sollte man Nix neben dem aktuellen OS installieren. Der Standard ist der <a href="https://docs.determinate.systems/getting-started/individuals/">Determinate Installer</a>, aber ich mag <a href="https://lix.systems">das Lix Projekt lieber, da es schneller ist</a>. Alternativ ist auch <a href="https://nixos.org/download/#nix-install-docker">der Nix-Docker-Container super um es mal auszuprobieren</a>. Wenn man m√∂chte, <a href="https://nixos.org/download/#nix-install-linux">kann man Nix (auf Linux) auch einfach in einen Ordner installieren und so verwenden (siehe "Single-User Mode")</a>. Das w√ºrde ich aber nur f√ºr ein paar Experimente empfehlen. Sowohl der Determinate als auch der Lix-Installer haben sehr gute Uninstaller die das Projekt auch wieder komplett entfernen k√∂nnen.</p>
<h2>2. Schritt: Imperativ verwenden</h2>
<p>Nix erlaubt es jederzeit ein Paket zu benutzen, ohne es zu installieren. Das ist eine Konsequenz davon wie der Paket-Manager aufgebaut ist. Ein Paket kann 'im <code>/nix/store/</code> sein' - ohne das es aktiv ist. Und der Befehl <code>nix run nixpkgs#fzf</code> startet es dann einfach - ohne es zu installieren. Alternativ gibt es auch <code>nix shell nixpkgs#fzf</code>. Damit erh√§llt man eine Shell, in der <code>fzf</code> installiert ist. Schlie√üt man die Shell, ist es auch wieder weg. üò≥</p>
<p>Dass ist der Hammer, weil man so Pakete ohne Reue ausprobieren kann. Ohne Sorgen, dass doch noch irgendwelche Abh√§ngigkeiten evtl. auf dem System herum gurken und man vergessen k√∂nnte ein Experiment wieder zu entfernen. Und das beste: Auch sp√§ter wird man dieses Feature die ganze Zeit verwenden.</p>
<p>Vorsicht vor <code>nix-env</code> und <code>nix profile</code> - das ist das √Ñquivalent zu dem wie man mit <code>homebrew</code>  und anderen Paketmanagern Pakete installieren w√ºrde. Diese sollte man so selten wie m√∂glich verwenden. Besser ist‚Ä¶</p>
<h2>3. Schritt: Entwicklungsumgebungen <code>shell.nix</code></h2>
<p>Das, was <code>nix shell nixpkgs#fzf</code> macht, kann man auch in eine Datei schreiben, und damit einfach in ein Repo mit einchecken. Schon hat man Deklarativ die ganzen Tools im Repo dokumentiert, die man braucht um mit einem Projekt zu arbeiten. Bonus: Ich kann f√ºr jedes Projekt eigene Versionen der Abh√§ngigkeiten haben (wenn ich das brauche). Python-Virtual-Envs auf Steroiden!</p>
<p>Hier ein Beispiel:</p>
<div class="hll"><pre><span></span><span class="p">{</span>
  pkgs <span class="o">?</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{</span> <span class="p">},</span>
<span class="p">}:</span>
pkgs<span class="o">.</span>mkShell <span class="p">{</span>
  <span class="ss">buildInputs</span> <span class="o">=</span> <span class="k">with</span> pkgs<span class="p">;</span> <span class="p">[</span>
    <span class="c1"># Add your build inputs here</span>
    pkgs<span class="o">.</span>python313
    pkgs<span class="o">.</span>uv
  <span class="p">];</span>
  <span class="ss">env</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">UV_PYTHON</span> <span class="o">=</span> pkgs<span class="o">.</span>python313<span class="p">;</span>
    <span class="ss">UV_DOWNLOAD_PYTHON</span> <span class="o">=</span> <span class="s2">&quot;never&quot;</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>Wenn man das mit <code>nix-shell</code> aufruft, dann hat man diese Python-Version zur Hand. <code>uv</code> verwendet diese und l√§dt selber keine Python-Versionen herunter. Nice! Extra nice: mit <code>nix-shell --pure</code>  hat man eine Shell in der <em>nur</em> das sichtbar ist was in dem <code>shell.nix</code> steht, und man kriegt Fehler f√ºr alles was man verwendet und in der <code>shell.nix</code> vergessen hat. ü§Ø</p>
<p>Bonus: <a href="https://direnv.net">Direnv</a> verwenden um automatisch die <code>shell.nix</code> und das <code>.env</code> zu laden. Dazu <a href="https://github.com/ajeetdsouza/zoxide">zoxide</a> um schnell in der Shell zwischen vielen Projekten hin und zu springen. Eine richtig geniale Entwicklungsumgebung.</p>
<p>Ich empfehle erst mal eine weile auf diesem Niveau zu bleiben, denn das ist schon ziemlich cool!</p>
<h2>4. Schritt: Mehr Tooling um besser mit Nix klar zu kommen</h2>
<ul>
<li>Pakete findet man am besten √ºber <a href="https://search.nixos.org/packages">die Webseite search.nixos.org</a> - aber ich mag eigentlich in der shell suchen. <code>nix run nixpkgs#nh search ut1999</code> funktioniert besser als alles was ich sonst bisher getestet habe.</li>
<li>Anzeigen was gerade installiert ist und wieso ist aufgrund der Architektur von nix gar nicht so einfach. <code>nix run nixpkgs#nix-tree</code> aproximiert das und gibt einen guten √ºberblick dar√ºber was man auf dem System hat.</li>
<li><code>nom</code> - der <a href="https://github.com/maralorn/nix-output-monitor">Nix-Output-Monitor</a> <code>nix run nixpkgs#nix-output-monitor</code> macht den output von l√§ngeren nix builds viel informativer und spannender. Verwenden kann man das so: <code>nix run $something |&amp; nix run nixpkgs#nix-output-monitor</code></li>
<li><code>nix store gc</code> um alles zu l√∂schen, was man mal testweise runtergeladen hat und nicht mehr auf der Platte braucht. (Einer Der Nachteile von Nix: Es verbraucht schnell <em>viel</em> Plattenplatz).</li>
</ul>
<h2>5. Schritt: Tief in das Hasenloch fallen</h2>
<p>Jetzt gibt es verschiedene Sachen die man sich anschauen k√∂nnte</p>
<ul>
<li><a href="https://nix.dev/manual/nix/2.24/language/index.html">Die Nix Sprache lernen</a> - die Voraussetzung f√ºr fast alles was danach kommt, also gut investierte Zeit. Und es ist eine wirklich kleine Sprache - auch wenn <a href="https://github.com/NixOS/nixpkgs">die 'Standard-Bibliothek' (meiner Meinung nach das NixPKGs Repository)</a> alles andere als klein ist.</li>
<li><a href="https://devenv.sh">devenv</a> um Entwicklungsumgebungen kurz und Knackig und mit allen Features deklarativ zu beschreiben und ins Projekt eingecheckt zu bekommen.</li>
<li><a href="https://nixos-and-flakes.thiscute.world">Flakes - der Standard in der Nix-Community, mit der Abh√§ngigkeits-Versionen festgeschrieben werden</a>. Also wie checke ich die genauen git commit hashes die ich verwendet habe um alle meine Software zu bauen ins Repo mit ein. Damit kann man ein Projekt auch nach Jahren sehr einfach verl√§sslich wieder bauen.</li>
<li><a href="https://github.com/pyproject-nix/uv2nix">uv2nix - wie man Python-Projekte Nix-ifiziert</a></li>
<li><a href="https://github.com/LnL7/nix-darwin">nix-darwin</a> um ein MacOS System so deklarativ zu verwalten, wie das unter NixOS geht. (OK, Apple setzt da grenzen, aber das ist trotzdem sehr cool).</li>
<li><a href="https://nix-community.github.io/home-manager/">home-manager</a> um dotfiles zu verwalten und auf Benutzer-Ebene alles zu konfigurieren.</li>
<li>Quasi alles von <a href="https://github.com/nix-community/awesome-nix?tab=readme-ov-file">Awesome-Nix</a>.</li>
<li>Und so viele Projekte mehr, die man sich anschauen k√∂nnte‚Ä¶</li>
</ul>

    </section>
    
      <footer>
        <a href="2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">
        Grundlegende Funktionen und Einstellungen des Terminals
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-11-25">Montag, 25. November 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p>Der Terminal-Emulator ist ein zentrales Werkzeug, mit dem wir Entwickler mit unseren Rechnern interagieren. Jedes bisschen Wissen und jede Effizienz, die du hier gewinnst, zahlt sich in k√ºrzester Zeit hundertfach aus.</p>
<p>Nat√ºrlich gibt es viele Terminals, wie <a href="https://iterm2.com">iTerm2</a>, <a href="https://alacritty.org">Alacritty</a> oder <a href="https://sw.kovidgoyal.net/kitty/">Kitty</a>. Aber ich finde, diese solltest du nur verwenden, wenn sie deinen Workflow wirklich verbessern. Und daf√ºr musst du zuerst wissen, was Apple standardm√§√üig mitliefert.</p>
<p>Das Sch√∂ne am Terminal ist, dass du unglaublich wenig anpassen musst, da es von Haus aus sehr gut funktioniert.</p>
<p>Ich nutze das eingebaute Terminal von macOS mit nur zwei (!) Konfigurationsanpassungen.</p>
<h2>Wortweise L√∂schen</h2>
<p><img src="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/delete-word.png" alt="Wortweise L√∂schen"></p>
<p>Die erste wirklich wichtige Anpassung f√ºr mich ist, dass ‚å•-‚å´ (Alt-Delete) als Standard-Keybinding gesetzt wird, damit wortweise nach links gel√∂scht wird. Damit passt du das Terminal an den Mac-Standard an, der in fast allen anderen Programmen ebenfalls funktioniert.</p>
<p>So geht's:</p>
<ol>
<li>Terminal ‚Üí Einstellungen √∂ffnen (‚åò-,).</li>
<li>Auf der linken Seite alle Profile ausw√§hlen, damit alle Einstellungen gleichzeitig bearbeitet werden.</li>
<li>Auf der rechten Seite ‚Üí "Tastatur" ausw√§hlen.</li>
<li>Einen neuen Shortcut hinzuf√ºgen.</li>
<li>Die Felder wie im Screenshot ausf√ºllen. <code>\027</code> steht f√ºr <strong>‚åÉ-w</strong> (<code>ctrl-w</code>), den Standard-Shortcut f√ºr wortweises L√∂schen in der Shell.</li>
</ol>
<h2>Ausgabe navigieren, selektieren und l√∂schen</h2>
<p>Die n√§chst-wichtigsten Shortcuts sind:</p>
<ul>
<li><strong>‚åò-N</strong> / <strong>‚åò-T</strong> / <strong>‚åò-W:</strong> Alles Standard, aber trotzdem meine meistbenutzten Shortcuts.</li>
<li><strong>‚åò-‚Üë</strong> und <strong>‚åò-‚Üì:</strong> Zum Anfang des vorherigen bzw. n√§chsten ausgef√ºhrten Befehls springen. Das ist super praktisch, um schnell nachzusehen, was die vorherigen Kommandos waren.</li>
<li><strong>‚åò-Shift-‚Üë</strong> und <strong>‚åò-Shift-‚Üì:</strong> Wie oben, aber selektiert zus√§tzlich. Damit kannst du schnell einen Befehl und dessen Ausgabe kopieren. Das ist super praktisch, um Anleitungen zu schreiben oder einem Kollegen zu zeigen, wie etwas gemacht wurde.</li>
<li><strong>‚åò-L:</strong> L√∂scht nur die Ausgabe des letzten Kommandos. Sehr praktisch, um ein nicht mehr ben√∂tigtes Shell-Experiment zu entfernen ‚Äì besonders bei Fehlern mit viel Output. Oft nutze ich das, wenn ich zuerst eine Hilfe anzeige und dann darunter verschiedene Experimente ausf√ºhre, um die richtigen Flags zu finden. (Genauer: <strong>‚åò-L</strong> l√∂scht vom Ende bis zur aktuellen Selektion und funktioniert daher hervorragend mit <strong>‚åò-‚Üë</strong>.)</li>
<li><strong>‚åò-K:</strong> Terminal l√∂schen. Die nukleare Option ‚Äì sie l√∂scht alles im aktuellen Terminal. Gro√üer Nachteil: Was weg ist, ist weg. Also nicht benutzen, wenn du den Output noch brauchst. Dennoch ist dies einer meiner am h√§ufigsten benutzten Shortcuts.</li>
</ul>
<h2>Unbegrenzter Puffer</h2>
<p><img src="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/unlimited-buffer.png" alt="Unbegrenzter Puffer"></p>
<p>Die zweite Anpassung, die ich vornehme, ist, den Scrollback-Puffer auf unbegrenzt zu stellen, damit ich die Ausgabe von langen Kommandos nicht verliere. Das geht so:</p>
<ol>
<li>Terminal ‚Üí Einstellungen √∂ffnen (<strong>‚åò-,</strong>).</li>
<li>Wie zuvor alle Profile ausw√§hlen.</li>
<li>Auf der rechten Seite ‚Üí "Fenster" ‚Üí "Zeilenpuffer" auf ‚Äûauf den verf√ºgbaren Speicher begrenzen‚Äú stellen.</li>
</ol>
<h2>Fazit</h2>
<p>Mit diesen Shortcuts kannst du ultraschnell zwischen den letzten Kommandos navigieren, deren Ausgabe selektieren (und kopieren) oder l√∂schen.</p>
<p>Diese Anpassungen und Shortcuts sind f√ºr mich auch einer der Hauptgr√ºnde, warum ich die eingebauten Terminals in IDEs nicht gerne benutze. Denn dort funktionieren sie oftmals nicht gut.</p>
<p>Viele dieser Einstellungen und Shortcuts gibt es auch auf der Ebene der Shell. Der Vorteil, sie √ºber das Terminal zu konfigurieren, ist, dass diese Shortcuts auch auf anderen Servern oder in Docker- bzw. Kubernetes-Containern funktionieren.</p>
<p>Ich hoffe, diese Tipps helfen dir, das Terminal noch besser zu nutzen.</p>
<p>Kennst du weitere n√ºtzliche Shortcuts oder Einstellungen, die ich nicht erw√§hnt habe? Hast du Fragen zu den vorgestellten Tipps? Lass es mich wissen!</p>
<p>Happy Shelling!</p>

    </section>
    
      <footer>
        <a href="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/">
        Wie kann KI beim Lernen mit Blooms-Taxonomie unterst√ºtzen?
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-10-10">Donnerstag, 10. Oktober 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/bloom.jpeg" alt="Blooms Taxonomie"></p>
<p>Nachem ich jetzt lange <a href="2024/10/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">√ºber Blooms Taxonomie</a> und <a href="2024/10/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">was die Ebenen</a> <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">im Detail bedeuten</a> geschrieben habe, kann ich jetzt <em>endlich</em> zu dem kommen, was mir eigentlich am Herzen liegt:</p>
<p>Mein ganzes Leben lang haben andere die Ebenen von Blooms Taxonomie verwendet um zu beurteilen wie gut ich etwas verstanden habe - aber man kann diesen Spie√ü auch umdrehen, und das wissen um diese Ebenen des Verst√§ndnisses nutzen um selbst besser zu lernen! (Ehrlich gesagt, bin ich ziemlich angepisst das mir das nicht von Vorne herein genau daf√ºr erkl√§rt und beigebracht wurde)</p>
<p>Wie funktioniert das? Wenn Mensch ohne Plan lernt, dann neigen wir dazu uns zun√§chst auf den unteren Ebenen zu bewegen. Denn das ist (vermeintlich) einfacher und erscheint logisch. Aber aus der Forschung wissen wir, dass sich von vorne herein auf Fragen der 4. und 5. Ebene (also Analysieren und Bewerten) zu konzentrieren, nicht nur schneller, sondern auch tieferes Verst√§ndnis bringt.</p>
<p>Warum? Weil sich die Art und Weise ver√§ndert mit der wir uns mit dem Lern-Material besch√§ftigen. Auswendig Lernen ist ja nicht verzichtbar. Man muss sich die Fakten ja merken. Aber das passiert auch, wenn man sie Analysiert und Bewertet - ABER - wir kriegen die Analyse und Bewertung gratis dazu. (Wohlgemerkt, f√ºr etwas mehr Kognitive Anstrengung, aber Entspannung ist ja nicht das Ziel.)</p>
<p>Und das ist der Clou. Gleicher Zeiteinsatz, aber tieferes Verst√§ndnis.</p>
<p>ü§Ø</p>
<p>Jetzt ist nat√ºrlich nicht jeder mit der F√§higkeit geboren, sich selbst einfach so Fragen auf der 4. und 5. Ebene zu stellen. Aber das ist auch gar nicht n√∂tig. Denn KI kann dabei prima helfen.</p>
<p>Chat-GPT hat ein sehr gutes Verst√§ndnis von Blooms-Modell und kann endlos fragen auf Bloom Level 4 und 5 zu jedem Thema generieren. Die sind nicht immer perfekt, es reicht aber, um sich darauf einzustimmnen wie solche Fragen aussehen und effizient selbst zu solchen Fragen zu kommen.</p>
<p>Und das ist f√ºr mich ein gamechanger, und super sinnvoller Einsatz von KI.</p>
<p>Hier mal ein Auszug aus einem <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/Python-Lernen-mit-Fragen.pdf">Chat mit Chat-GPT</a>. Das ist sicher nicht perfekt, aber ein starker Anfang. Chapeau, Chat-GPT!</p>

    </section>
    
      <footer>
        <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">
        Was ist blooms taxonomie? Die &#39;wichtigsten&#39; oberen Ebenen
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-09-06">Freitag, 6. September 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/bloom.jpeg" alt="Blooms Taxonomie"></p>
<p>In <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">meinem ersten Blog-Post habe ich mich mit Blooms Taxonomie besch√§ftigt</a>. Im <a href="2024/9/was-ist-blooms-taxonomie-ebene-1-3/">zweiten ging es um die ersten drei Ebenen seines Lernmodells</a>. Hier geht es jetzt um die mir am wichtigsten ebenen vier und f√ºnf. Und der Vollst√§ndigkeit halber auch auch um die sechste.</p>
<p>Und los gehts!</p>
<h2>Die Ebenen von <a href="https://de.wikipedia.org/wiki/Blooms_Taxonomie">Blooms Taxonomie</a>:</h2>
<h3>4. Analyse</h3>
<p>Auf dieser Ebene geht es darum, Wissen und Informationen in seine Bestandteile zu zerlegen um Beziehungen und Strukturen zu erkennen und Verstehen. Hier geht es erstmals um kritisches Denken und das erkennen von Mustern.</p>
<p><em>Fragen</em>: "Welche Elemente bilden das Gesamtkonzept?" oder "Wie h√§ngen die Teile zusammen?" und "Was sind die zugrunde liegenden Annahmen?" Diese Fragen helfen uns, tiefer in das Thema einzutauchen und es aus verschiedenen Perspektiven zu betrachten.</p>
<p><em>T√§tigkeit</em>: Untersuchen, Zerlegen, Beziehungen erkennen, Vergleichen. Hier geht es darum, das erlernte Wissen zu analysieren, zu hinterfragen und mit schon gelerntem aus anderen Themen zu vergleichen und zu kontrastieren.</p>
<p>Die F√§higkeit, komplexe Informationen zu durchdringen und logische Verbindungen herzustellen.</p>
<p><em>Lernziel</em>: Ich kann komplexe Informationen durchdringen, zerlegen und logische Beziehungen erkennen. Auch zu anderem bisher gelernten. Das Ergebnis dieser Lernstufe ist die F√§higkeit, das Gelernte zu analysieren und zu hinterfragen.</p>
<p>Daher ist diese Ebene und Ihre Fragestellung auch mit der n√§chsten so wichtig, um langfristig zu behalten was man gelernt hat (verkn√ºpfungen und kontrastierung zu anderem was man schon kann). Au√üerdem: Wenn man sich von Anfang an mit diesen Fragen besch√§ftigt, kriegt man in der gleichen Lernzeit Ebene 1-3 quasi umsonst.</p>
<p><em>Beispiel</em>: Ein Softwareentwickler k√∂nnte beispielsweise den Code eines Programms analysieren, um Fehler zu finden oder um zu verstehen, wie verschiedene Teile des Codes zusammenarbeiten. In einem Konflikt k√∂nnte ich die Argumente analysieren, um Bestandteile, Beziehungen zwischen den Argumenten und die dahinter stehenden Annahmen, deren Logik, und die historische Beziehung der konflikteten Parteien zu bewerten.</p>
<h3>5. Evaluieren</h3>
<p>Jetzt, wo wir das Wissen analysiert und zerlegt haben, geht es darum, dieses Wissen zu bewerten, zu kritisieren und zu priorisieren. Es geht darum, fundierte Urteile zu f√§llen und Kritik zu √ºben.</p>
<p><em>Fragen</em>: "Ist diese These Valide?", "Wie effektiv ist diese Methode?", "Welche vor und Nachteile hat dieser Ansatz?", "Welcher andere Ansatz ist aus welchen Gr√ºnden besser?" oder "Welche Methode sollte ich priorisieren?" Diese Fragen helfen uns, das Wissen zu bewerten und Entscheidungen zu treffen.</p>
<p><em>Lernziel</em>: Das Ergebnis dieser Lernstufe ist die F√§higkeit, das Gelernte kritisch anhand der f√ºr meine Situation relevanten Kriterien zu bewerten und Entscheidungen zu treffen. Es geht darum, das Wissen zu nutzen, um fundierte Entscheidungen zu treffen und Priorit√§ten zu setzen.</p>
<p><em>T√§tigkeit</em>: F√ºhren von Debatten, Entscheidung zwischen Ans√§tzen, Bewerten von Projekten und Theorien. Hier geht es darum, das erlernte Wissen zu bewerten und zu priorisieren.</p>
<p><em>Beispiel</em>: In einem Projekt oder bei der Softwareentwicklung verschiedene Strategien oder Umsetzungsm√∂glichkeiten bewerten und entscheiden, welche am besten umgesetzt werden sollte. Oder auch kleiner: Bewertung der Glaubw√ºrdigkeit einer Quelle. Kritisches hinterfragen von Ma√ünahmen und (politischen) Entscheidungen.</p>
<h3>6. Erzeugen</h3>
<p>Einleitung: Die h√∂chste Ebene ist das Erschaffen, bei dem ein neues oder originelles Werk entwickelt wird. Es geht darum, Wissen und Ideen auf innovative Weise zu kombinieren und neue Konzepte zu entwickeln.</p>
<p><em>Fragen</em>: "Was w√§re, wenn...?" oder "Wie k√∂nnte ich...?". "K√∂nnte ich [Problem X] vielleicht auch ganz anders angehen?", "Kann ich diese Konzepte vielleicht auch so kombinieren?"</p>
<p><em>Lernziel</em>: Kreativit und Innovativ eigene Ideen in Produkte umsetzen.</p>
<p><em>T√§tigkeit</em>: Entwickeln von Projekten oder Modellen. Schreiben von Texten. Entwerfen von Experimenten oder Prototypen.</p>
<p><em>Beispiel</em>: Als Softwareentwickler entwickle ich eine Software. Ich schreibe ein Gedicht. Ich f√ºhre eine neue Software ein um ein altes Problem neu besser zu l√∂sen.</p>
<h2>Warum ist mir das so wichtig?</h2>
<p>Seit den 1960er Jahren wird Blooms Taxonomie dazu verwendet, um einzusch√§tzen, wie gut ich und andere ein Thema verstanden haben. Und erst jetzt kriege ich raus, dass es a) existiert, und ich es b) dazu verwenden kann mein eigenes Lernen besser zu verstehen und zu vertiefen? Boah ey, wieso hat mir das in der Schule niemand erkl√§rt? Oder wenn, wieso dann nicht auf eine Weise die ich verstanden habe? Ich f√ºhle mich im Moment so, als wurde mir hier √ºber Jahre etwas wichtiges vorenthalten.</p>
<p>So, das wars. Jetzt wisst Ihr so viel √ºber das Modell und seine Ebenen wie ich auch. <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/">N√§chstes mal soll es dann darum gehen wie man mit hilfe von KI sich selbst auf die Ebene des Lernens Katapultieren kann auf der man gerade sein will.</a></p>
<p>Bis dahin, bleibt neugierig und probiert es doch mal aus in diesen Kategorien √ºber euer eigenes Lernen nachzudenken.</p>

    </section>
    
      <footer>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">
        Was ist blooms taxonomie? Die ersten Ebenen
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-09-06">Freitag, 6. September 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/bloom.jpeg" alt="Blooms Taxonomie"></p>
<p>In <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">meinem letzten Blog-Post habe ich mich mit Blooms Taxonomie besch√§ftigt</a>. Mir hat dieses Modell viele Gedankenanst√∂√üe dar√ºber gegeben, wie ich lerne. Ich habe die sechs Ebenen von Blooms Taxonomie vorgestellt und ihre Anwendung sehr knapp diskutiert. Heute m√∂chte ich diese Ebenen vertiefen und anhand von Beispielen auf die Unterschiede zwischen den Ebenen eingehen sowie die jeweiligen Lernziele beleuchten. Mein Ziel ist es, mir und anderen, die Anwendung von Blooms Taxonomie in beim Lernen zu veranschaulichen. Los gehts!</p>
<h2>Die Ebenen von <a href="https://de.wikipedia.org/wiki/Blooms_Taxonomie">Blooms Taxonomie</a>:</h2>
<h3>1. Wissen</h3>
<p>Die Grundlage f√ºr alles. Hier geht es darum, sich an Fakten und Informationen zu erinnern. (Wer h√§tte das gedacht? ;)</p>
<p><em>Fragen</em>: "Was sind die Fakten?" oder "Was wei√ü ich √ºber dieses Thema?"</p>
<p><em>T√§tigkeit</em>: Sich was merken. Hier helfen z.B. Ged√§chtnis-Tricks wie ein <a href="https://de.wikipedia.org/wiki/Ged√§chtnispalast">Ged√§chtnispalast</a>, aber meine Empfehlung ist ein durchsuchbares Notizbuch als externalisiertes Ged√§chtnis zu f√ºhren. Warum? Weil das wunderbar f√ºr alle weiterne Ebenen verwendbar ist. :) Ich verwende derzeit <a href="https://www.agenda.com">Agenda</a>, aber wenn ich jetzt neu anfangen w√ºrde, <a href="https://logseq.com">w√ºrde ich Logseq verwenden</a>.</p>
<p><em>Lernziel</em>: Ich kann dieses Wissen wiedergeben. Wenn Du aber nur auf dieser Ebene lernst, dann geht es Dir wie mir nach den Klausuren - eine Woche Sp√§ter hatte ich das meiste erfolgreich wieder vergessen. :)</p>
<p><em>Beispiel</em>: Welche Module und Funktionen gibt es grob in der Standardbibliothek meiner Programmiersprache? Oder: Welche Themen muss ich f√ºr die Klausur kennen? Welche Punkte hat jedes Unterthema?</p>
<h3>2. Verst√§ndnis</h3>
<p>Aufbauend auf Wissen, geht es jetzt darum Informationen zu interpretieren, zu erkl√§ren und erste Zusammenh√§nge herzustellen.</p>
<p>Es reicht nicht mehr aus, nur Fakten zu kennen, sondern es ist wichtig, ihre Bedeutung zu verstehen und sie in einen Kontext einzuordnen.</p>
<p><em>Fragen</em>: "Kann ich das Gelernte in eigenen Worten erkl√§ren?" oder "Kann ich ein Beispiel f√ºr das Gelernte geben?" Damit kann ich das Gelernte verstehen und in einen Kontext einordnen.</p>
<p><em>T√§tigkeit</em>: Interpretieren, Erkl√§ren, In eigenen Worten wiedergeben, Zusammenfassen, mit schon gelerntem Vergleichen, Beispiele geben.</p>
<p><em>Lernziel</em>: Ich kann das gelernte jemand anderem erkl√§ren. (Also unter andere dass, was ich hier gerade mache). Damit kriege ich selbst ein viel tieferes Verst√§ndnis der Materie, und vergesse es auch viel weniger. Hier greift die alte Volksweisheit: Wer lehrt, lernt zweimal.</p>
<p><em>Beispiel</em>: vor einer Klausur einen guten und vollst√§ndigen Spickzettel zu schreiben ist super. √úberraschung: den braucht man in der Klausur dann √ºblicherweise nicht. :) Warum hilft das? Weil man hier strukturiert die (Lern)-Notizen zusammenfasst. Gerne als Mind-Map oder als Info-Graphik. Optimal: In einer Lern-Gruppe oder einem Kollegen etwas erkl√§ren.</p>
<h3>3. Anwendung</h3>
<p>Mit dem Verst√§ndnis an der Hand, geht es jetzt darum Wissen in die Praxis zu √ºbersetzen. Gefordert sind (noch) keine gro√üen √úbertragungsleistungen, sondern eine direkte Anwendung des Gelernten in bekannten Kontexten.</p>
<p><em>Fragen</em>: "Wie kann ich das Gelernte in einer bestimmten Situation oder bei einer bestimmten Aufgabe anwenden?" oder "Welche Probleme kann ich mit diesem wissen l√∂sen?" Es geht darum das Gelernt auf bekannte Probleme anzuwenden.</p>
<p><em>T√§tigkeit</em>: Anwenden, Ausf√ºhren, Durchf√ºhren. Hilft alles nichts, man muss es mal praktisch in bekannten und neuen Situationen anwenden.</p>
<p><em>Lernziel</em>: Ich kann das Gelernte in √§hnlichen Kontexten anwenden. Das Ergebnis dieser Lernstufe ist die F√§higkeit, einfache Probleml√∂sungen durchzuf√ºhren. Es geht darum, das Gelernte in die Praxis umzusetzen und zu zeigen, dass man das Wissen nicht nur besitzt, sondern auch anwenden kann.</p>
<p><em>Beispiel</em>: Ein Programmierer k√∂nnte <a href="https://adventofcode.com">eine Aufgabe aus Advent Of Code</a> l√∂sen um das dahinter liegende Konzept zu verstehen. Ein Administrator nach einer Schulung die Sicherheitseinstellungen eines Netzwerk Pr√ºfen und verbessern. Ein Agiler Team-Teilnehmer ein neu gelerntes Projekt-Management Werkzeug in einem agilen Experiment ausprobieren.</p>
<h2>Fazit</h2>
<p>Beim Schreiben ist mir aufgefallen wie schwer es ist diese Ebenen kurz und Knapp vorzustellen. Es gibt ja noch drei weitere Ebenen, aber ich wollte eure gesch√§tzte Aufmerksamkeit nicht noch weiter Qu√§len. :)</p>
<p>Daher habe ich hier abgetrennt. Diese ersten Ebenen sind zwar essenziell um zu verstehen wie das alles gemeint ist. Aber den eigentlichen Schatz heben wir erst auf der 4. und 5. Ebene: Analyse und Evaluation. <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">Und darum geht es (sicher f√ºr den geehrten Leser v√∂llig √ºberraschend) in meinem n√§chsten Blog Post</a>. :)</p>

    </section>
    
      <footer>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">
        W√§hrend dem lernen Lernen lernen - Blooms Taxonomie
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-09-06">Freitag, 6. September 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/bloom.jpeg" alt="Die Lernpyramide nach Bloom"></p>
<p>Vor einigen Wochen bin ich √ºber¬†<a href="https://www.youtube.com/watch?v=1xqerXscTsE">ein wundervolles Youtube Video gestolpert, dass mich √ºber Blooms Taxonomie des Lernens informiert hat</a>. Bloom stellt darin eine faszinierende Methode vor, mit der man sich Wissen √ºber ein Thema schnell und effektiv aneignen kann.</p>
<p>Das hat mich ein bisschen umgehauen, da ich in alle den Jahren in denen ich gelernt habe noch nie davon geh√∂rt hatte. Endlich ein brauchbares Modell, wieso manche meiner Lerngewohnheiten gut oder eben schlecht funktionieren.¬†</p>
<p>In kurz, <a href="https://de.wikipedia.org/wiki/Blooms_Taxonomie">Blooms Taxonomie</a> ist ein Modell aus den 60' er Jahren, in dem er postuliert das es sechs Ebenen des Lernens gibt. Diese werden gerne als Pyramide visualisiert, was ich ung√ºnstig finde ‚Üí dazu gleich mehr. ¬†</p>
<p>Die Pyramide f√§ngt ganz unten (1) mit dem Auswendiglernen an. Dann lernt man (2) wie man Gelerntes erkl√§rt. Dann (3) wendet man es direkt an. Dann lernt man (4) es mit anderem Wissen zu vergleichen. Dann es (5) gegen andere Ans√§tze zu priorisieren. An der Spitze der Pyramide (6) gewinnt man aus der Erfahrung aus der Anwendung, gewappnet mit den Analysen und Vergleichen, neue Erkenntnisse und Dokumentieren diese (zum Beispiel als Blog-Post).</p>
<p>Wenn man das sieht, erscheint es logisch, dass man diese Stufen brav der Reihe nach von unten nach oben durchl√§uft.</p>
<p><em>Und das ist der Clou - das ist genau falsch.</em></p>
<p>Stattdessen ist es viel schlauer, sofort mit dem Analysieren und Evaluieren anzufangen (Level 4 und 5).</p>
<p>Ja, das ist Anstrengender, ¬†aber man kriegt damit die ersten drei Ebenen geschenkt, denn es passiert automatisch wenn man sich selbst mit den Fragen der Ebene 4 und 5 herausfordert.</p>
<p>Dazu kann mann jetzt auch noch Vergleichen wie sich das neue Wissen in das bereits gelernte einordnet, und Begr√ºnden, in welchem Kontext welcher der Ans√§tze die man kennt besser funktionieren.</p>
<p>Also: Versucht es mal! <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">N√§chstes mal gehe ich noch mal tiefer darauf ein was die einzelnen Ebenen ausmacht</a> und danach, wie man KI daf√ºr verwenden kann sich selbst beim lernen sofort auf Ebene vier und f√ºnf zu katapultieren!¬†</p>

    </section>
    
      <footer>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/6/rich-und-objexplore-um-python-code-interaktiv-zu-verstehen/">
        rich und objexplore um Python code interaktiv zu verstehen
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-06-24">Montag, 24. Juni 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p>Da ich sie selber nicht so soft ben√∂tige und dann immer vergesse wie sie hei√üen hier als Notiz an mich selbst:</p>
<ul>
<li><a href="https://rich.readthedocs.io/en/stable/introduction.html?highlight=inspect#rich-inspect"><code>rich.inspect()</code></a> ist super hilfreich um zu einem Objekt das man im Debugger vor Sich hat schnell eine √úbersicht zu generieren was es kann und welche Daten es hat.</li>
<li><a href="https://pypi.org/project/objexplore/"><code>objexplore.explore()</code></a> baut auf rich auf und bietet einen interaktiven explorer mit im wesentlichen den gleichen Informationen.</li>
</ul>
<p>Beide Tools sind super hilfreich, wenn man in einer (fremden) Code-Basis schnell einen √ºberblick kriegen will wie Objekte interagieren und zusammenarbeiten.</p>

    </section>
    
      <footer>
        <a href="2024/6/rich-und-objexplore-um-python-code-interaktiv-zu-verstehen/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/5/wie-nutze-ich-die-shell-effektiv/">
        Wie nutze ich die Shell effektiv
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-05-24">Freitag, 24. Mai 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/5/wie-nutze-ich-die-shell-effektiv/hacker.jpeg" alt="H√§cker bei der Arbeit‚Ä¶">
Bei meiner Arbeit ist mir aufgefallen, dass viele Entwickler bei uns die Shell viel effektiver nutzen k√∂nnten, um ihre Arbeit besser und schneller zu machen. Da ich die Shell sehr viel nutze, habe ich dazu ein paar Ideen.¬†üòá Auf der anderen Seite gibt es immer wieder ein Nugget, das ich selbst nicht kenne ‚Äì und das m√∂chte ich nat√ºrlich auch lernen. ¬†</p>
<p>In diesem Sinne: Ich freue mich √ºber Tips, lasst uns gerne daraus einen Austausch machen, wie man seine Shell effektiv einsetzt.</p>
<p>Damit verst√§ndlich wird wie ich meine Shell verwende ist es wichtig zu verstehen dass es verschiedene Arten gibt einen Mac effektiv zu nutzen. Ich kategorisiere das f√ºr mich grob so:</p>
<ul>
<li>Fensterbasiert: Viele Fenster, oft klein, die sich gegenseitig teilweise verdecken. Spezialisierte Apps anstatt Monolithen. Terminal, Editor, Git GUI, Datenbank-GUI und ein Dokumentationsbrowser, anstatt einer IDE die alles inkludiert.</li>
<li>Screen/Tmux Style: Auch viele Fenster, aber ohne das diese sich √ºberlappen. Viel Full-Screen und oft ein Window Manger oder Terminal das sicherstellt das Fenster garantiert nebeneinander sind. IDEs arbeiten in der Regel so.</li>
<li>Quake Shell-Style: Im wesentlichen irgend ein anderer Stil, aber mit einem globalen Shortcut, der jederzeit eine Shell in den Vordergrund bringt oder wieder verschwinden l√§sst - egal wo man gerade ist.</li>
<li>Mehrere Desktops: Separation von Apps √ºber mehrere Desktops oder Workspaces.</li>
</ul>
<p>Ich bin ganz klar tief in dem Fensterbasierten Workflow verortet. Ich kenne nat√ºrlich auch die anderen Workflows, aber sie funktionieren f√ºr mich pers√∂nlich einfach nicht so gut. Ich finde √ºberlappende Fenster wirklich gro√üartig, weil ich damit auf einem sehr viel kleineren Bildschirm (14-Zoll-Notebook) genauso produktiv sein kann, wie auf einem sehr viel gr√∂√üeren Bildschirm.¬†</p>
<p>Ich hoffe sehr, dass die Apple-Vision bald so gut funktioniert und so leicht wird, wie ich es mir w√ºnsche. Dann kann ich es mir meine Fenster fei um mich herum anordnen. Aber bis dahin bleibe ich bei √ºberlappenden Fenstern.</p>

    </section>
    
      <footer>
        <a href="2024/5/wie-nutze-ich-die-shell-effektiv/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/4/chestertons-fence-oder-was-ist-denken-zweiter-ordnung/">
        Chestertons Fence oder was ist Denken zweiter Ordnung?
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2024-04-18">Donnerstag, 18. April 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><a href="https://fs.blog/chestertons-fence/">Mir hat dieser Artikel √ºber das Denken zweiter Ordnung sehr gut gefallen.</a></p>
<p><img src="2024/4/chestertons-fence-oder-was-ist-denken-zweiter-ordnung/chestertons-fence.jpeg" alt="Einsam stehendes Auto vor einem Zaun √ºber eine Stra√üe"></p>
<p>Er erkl√§rt am Beispiel von 'Chestertons-Fence', warum es wichtig ist, vor √Ñnderungen an Systemen das Denken zweiter Ordnung einzusetzen.
Er nutzt dazu die Methapher eines Zauns √ºber eine Stra√üe. Diesen sollte man nicht einfach wegr√§umen, nur weil er nervt. Warum? Weil die Menschen die ihn gebaut haben hatten damit Aufwand, den Sie nicht einfach nur so zum Spa√ü investiert haben. Deren Gr√ºnde muss man verstehen um zu sehen ob der Zaun tats√§chich weg kann, oder nach wie vor n√∂tig ist.</p>
<p>Angenommen hinter dem Zaun befindet sich ein Stra√üenabschnitt, der mit Minen verseucht ist. Leider ist dies in der Ukraine ja ein h√§ufiges Problem. Der Zaun sollte erst entfernt werden, wenn die Minen ger√§umt sind, um Todesf√§lle und Verletzungen zu vermeiden. Die Toten und Verletzten sind hier der Effekt zweiter Ordnung.</p>
<p>Denken zweiter Ordnung hei√üt also nicht nur zu hinterfragen, warum etwas so ist, wie es ist, sondern auch zu verstehen, warum die Menschen, die es geschaffen haben (in unserem Fall meistens Code), es auf diese Weise gebaut haben. Bevor ich √Ñnderungen vornehme, sollte ich mir Zeit nehmen, um die Gr√ºnde f√ºr die urspr√ºngliche Gestaltung zu verstehen, da unbedachte √Ñnderungen unerw√ºnschte Effekte haben werden.</p>
<p>So zu denken finde ich nicht leicht. Oft misslingt es mir. Aber es ist f√ºr mich ein Ziel.</p>
<h2>Was hei√üt das f√ºr uns Entwickler?</h2>
<p>Besonders bei der Frage: Wieso sind unsere Systeme so wie sie sind? Ist das f√ºr mich super relevant. Aber auch immer wenn ich Programmiere. Wenn ich einen Zaun aufstelle, also z.B. etwas komplizierter mache als es sein k√∂nnte, dann schreibe ich einen Kommentar wieso ich mich gegen die einfachere L√∂sung entschieden habe, damit die nach mir kommenden verstehen ob meine - f√ºr Sie - √ºberkomplizierte L√∂sung noch n√∂tig ist.
Wenn ich eine weiter reichende Entscheidung f√§lle, dann Dokumentiere ich diese gerne mit eineme Architektural Decision Record (ADR) der enth√§llt aus welchen Gr√ºnden wir uns so entschieden haben.
Wenn ich eine Story schreibe, dann muss da nicht nur das Feature drauf, sondern eben auch der Grund daf√ºr, damit ich oder andere sp√§ter nachvollzieen k√∂nnen, wieso dieses Feature existiert, oder eben wieso es nicht mehr n√∂tig ist.
Idealerweise w√ºrde ich auch gerne vom Code √ºber die Commits zur Story zur√ºck kommen - aber das gelingt mir bisher regelm√§√üig nicht.</p>
<h2>Fazit</h2>
<p>Viele der Praktiken, die wir in der Softwareentwicklung als Standards ansehen, dienen eigentlich dazu, das Denken zweiter Ordnung zu erleichtern ‚Äì ein wichtiger Zusammenhang, der oft unerw√§hnt bleibt, mir aber zunehmend klarer wird.</p>
<p>Ganz besonders wichtig ist mir aber der Respekt, im Zweifel sollte ich erst einmal annehmen das der andere sich etwas dabei gedacht hat. Bevor ich das nicht verstehe sollte ich nicht die Axt ansetzen.</p>

    </section>
    
      <footer>
        <a href="2024/4/chestertons-fence-oder-was-ist-denken-zweiter-ordnung/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
  
  
    
  <div class="pagination">
    
      <span class="disabled">&laquo; Previous</span>
    
    | 1 |
    
      <a href="page/2/">Next &raquo;</a>
    
  </div>

  

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2025 <a href="../work/">Martin H√§cker</a></span>
  </li>
  
    
    <li class="nav-item imprint">
      <a class="nav-link" href="../meta/#imprint">
        Impressum
      </a></li>
  
    
    <li class="nav-item privacy-policy">
      <a class="nav-link" href="../meta/#privacy-policy">
        Datenschutzerkl√§rung
      </a></li>
  
    
    <li class="nav-item colophon">
      <a class="nav-link" href="../meta/#colophon">
        Kolophon
      </a></li>
  
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    <a class="nav-link" 
      rel="license" 
      target="_blank" 
      href="https://creativecommons.org/licenses/by-sa/4.0/deed.de"
    >
      <img 
        src="/static/cc-by-sa-88x31.png"
        alt="Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 Internationale Lizenz"
      >
    </a>
  </li>
</ul>
    </footer>
  </body>
</html>
