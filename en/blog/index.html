
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="../../static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../static/style.css">
    <link rel="stylesheet" href="../../static/pygments.css">
    <title>Blog</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin HÃ¤ckers Blog Artikel" href="../../blog/feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="../" class="navbar-brand ">ğŸ </a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="../work/" class="nav-link">Professional software development</a></li>
    
      <li class="nav-item "><a href="../projects/" class="nav-link">Projects</a></li>
    
      <li class="nav-item "><a href="../publications/" class="nav-link">Publications and talks</a></li>
    
      <li class="nav-item active"><a href="./" class="nav-link">Blog<span class="sr-only">(ausgewÃ¤hlt)</span></a></li>
    
      <li class="nav-item "><a href="../categories/" class="nav-link">Categories</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="../../blog/">ğŸ‡©ğŸ‡ª</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="./">ğŸ‡¬ğŸ‡§</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

  

<a class="breadcrumb-item " href="../">ğŸ </a>


<a class="breadcrumb-item active" href="./">Blog</a>

</nav>
    </header>
    <article class="page blog  container-fluid">
      
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/6/nuetzliche-shell-kommandos-sort-uniq/">
        NÃ¼tzliche Shell-Kommandos: sort, uniq
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2025-06-25">Wednesday, June 25, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2025/6/nuetzliche-shell-kommandos-sort-uniq/set-operations.png" alt="Set Operations">
Weil ich es heute wiederholt nachschlagen musste, hier noch eine Erinnerung an mich selbst, wie einfach es ist auf der Shell set Operationen durchzufÃ¼hren.</p>
<p>In unserem Beispiel: ~10k Datenbank-IDs hier, ~15k Datenbank-IDs da, und die Frage welche davon nur in der einen Liste enthalten sind. Das ist dann einfach zu beantworten, wenn man die auf eine ID pro Zeile ausgibt, und dann einfach mit <code>set_difference</code> bearbeitet.</p>
<div class="hll"><pre><span></span>set_union<span class="w"> </span><span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span>sort<span class="w"> </span><span class="nv">$1</span><span class="w"> </span><span class="nv">$2</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>uniq
<span class="o">}</span>

set_intersection<span class="w"> </span><span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span>sort<span class="w"> </span><span class="nv">$1</span><span class="w"> </span><span class="nv">$2</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>uniq<span class="w"> </span>--repeated
<span class="o">}</span>

set_difference<span class="w"> </span><span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span>sort<span class="w"> </span><span class="nv">$1</span><span class="w"> </span><span class="nv">$2</span><span class="w"> </span><span class="nv">$2</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>uniq<span class="w"> </span>--unique
<span class="o">}</span>

set_symmetric_difference<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span>sort<span class="w"> </span><span class="nv">$1</span><span class="w"> </span><span class="nv">$2</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>uniq<span class="w"> </span>--unique
<span class="o">}</span>
</pre></div>
<p><a href="https://stackoverflow.com/a/13038235/4572750">Quelle</a></p>

    </section>
    
      <footer>
        <a href="2025/6/nuetzliche-shell-kommandos-sort-uniq/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/6/devopscon-stolperfallen-beim-aufbau-interner-developer-platforms-idp/">
        DevOpsCon: Stolperfallen beim Aufbau interner Developerâ€¯PlatformsÂ (IDP)
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2025-06-19">Thursday, June 19, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p>Heute gibts den Start meines Berichts von der DevOpsCon 25. So viel allgemeines vorweg: War schÃ¶n.  Druckbetankung wie es sich gehÃ¶rt.</p>
<p>Los ging es mit einer Keynote Ã¼ber interne Entwickler-Plattformen und was dabei gerne schief geht.</p>
<h2>1â€¯|â€¯Reality-Check: 90 % der Devs nutzen schon eine IDP â€“ wir auch</h2>
<ul>
<li>Laut Jessica arbeiten rundâ€¯90â€¯% aller Entwickler:innen mittlerweile mit einer internen Plattform â€“ oft, ohne es zu merken.</li>
<li>Wir auch? Was ist unsere Plattform?</li>
</ul>
<h2>2â€¯|â€¯Das theoretische Fundament</h2>
<p>Jessica empfahl <em>vier BÃ¼cher</em>, die jede:r Platformâ€‘Builder kennen sollte. (Lustigerweise gab Sie zu, das Sie selbst noch nicht alle davon gelesen komplett gelesen hat.)</p>
<table>
<thead><tr>
<th>Buch</th>
<th>Kernaussage fÃ¼r IDP</th>
<th>Mein Takeâ€‘away</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="https://www.amazon.com/Transformed-Becoming-Product-Driven-Company-Silicon/dp/1119697336">Transformed</a></strong></td>
<td>Von Silos zu <strong>empowereden Produktâ€‘Teams</strong></td>
<td>Auch Plattformâ€‘Teams brauchen Produktdenken und Produkt-Manager.</td>
</tr>
<tr>
<td><strong><a href="https://www.amazon.com/Team-Topologies-Organizing-Business-Technology/dp/1942788819">Team Topologies</a></strong></td>
<td><strong>Teamâ€‘Typen &amp; Schnittstellen</strong> (u.â€¯a. Platform &amp; Enabling Teams)</td>
<td>Klingt sehr Ã¤hnlich zu dem wie wir organisiert sind. Unterschiede: Komplizierte Subsysteme brauchen eigene Teams. Enablingâ€‘Teams sind hier fast immer <strong>temporÃ¤r</strong>.</td>
</tr>
<tr>
<td><strong><a href="https://www.amazon.de/Accelerate-Software-Performing-Technology-Organizations/dp/1942788339">Accelerate</a></strong></td>
<td>Deployâ€‘Freq., Leadâ€‘Time, Failureâ€‘Rate, MTTR</td>
<td><a href="https://dora.dev/guides/dora-metrics-four-keys/">DORAâ€‘Scores</a> = Proxy fÃ¼r Platform-Teamâ€‘Erfolg. Nugget: Im Raum war niemand der alle 4 Metriken einsetzt, oder jemanden kennt der das tutâ€¦</td>
</tr>
<tr>
<td><strong><a href="https://www.amazon.de/Platform-Engineering-Technical-Product-Leaders/dp/1098153642">Platform Engineering</a></strong></td>
<td><strong>Plattform ersetzt Glueâ€‘Code</strong> &amp; schafft Selfâ€‘Service</td>
<td>Eine IDP ist <strong>Software</strong>, kein Opsâ€‘Team.</td>
</tr>
</tbody>
</table>
<h2>3â€¯|â€¯Typische Fallstricke</h2>
<ol>
<li><strong>Menschen im Plattform-Team bringen ihre Erfahrungen mit</strong><ul>
<li>â€Itâ€™s faster if I just do it.â€œ Sorgt gerne dafÃ¼r das das Ergebnis auch nur Sie benutzen kÃ¶nnen.</li>
<li>Damit erzeugt man ein neues Ops-Silo. Dringend zu vermeiden. Das Ziel ist, das andere Teams sich selbst helfen kÃ¶nnen.</li>
</ul>
</li>
<li><strong>Rudis Resterampe</strong> (ScopeÂ Creep)<ul>
<li>Plattformâ€‘Team sammelt alles, was sonst niemand machen will.</li>
<li>Konsequenz: Keine Zeit mehr fÃ¼r strategische Funktionen.</li>
<li>Braucht eine klare Vision, und insbesondere By-In von Leadership. Dann Iterationen und viel Kommunikation.</li>
</ul>
</li>
<li><strong>Alles sofort lÃ¶sen wollen (Rudis Resterampe 2.0)</strong><ul>
<li>Minimalismus ist KingÂ ğŸ‘‘. Nicht jedes Problem muss gleich gelÃ¶st werden.</li>
<li>Priorisiere <strong>Onboarding, Selfâ€‘Service &amp; Empowerment</strong>.</li>
</ul>
</li>
<li><strong>Das falsche Problem LÃ¶sen</strong><ol>
<li>Es ist sehr einfach das falsche Problem zu lÃ¶sen. SchlieÃŸlich sind wir alle Entwickler und wissen was wir brauchen.</li>
<li>Aber jedes Team ist anders und hat andere Aufgaben. Daher ist es unglaublich wichtig mit den Menschen intensiv zu sprechen die man beglÃ¼cken will.</li>
<li>Plattform-Engineering braucht genauso Produkt-Management und einen Produkt-Manager wie andere Themen. Wenn das Budget dafÃ¼r nicht vorhanden ist, muss man diese Aufgaben trotzdem erfÃ¼llen.</li>
</ol>
</li>
<li><strong>Plattformâ€‘Migrationen unterschÃ¤tzen</strong><ul>
<li>Jede Migration ist Schmerzhaft undÂ <strong>kostet Vertrauen</strong> (Vertrauen ist wie eine WÃ¤hrung. Wenn man es ausgegeben hat, ists wech).</li>
<li>Daher so wenig Migrationen wie mÃ¶glich, und diese gut vorbereiten, auch wenn es viel Aufwand erzeugt.</li>
<li>Ziel: <strong>Automatisierte, Lowâ€‘Impactâ€‘Migrationspfade</strong>.</li>
</ul>
</li>
</ol>
<h2>4â€¯|â€¯Fragen an den Leser</h2>
<ol>
<li><strong>Was ist deine aktuelle Plattform?</strong></li>
<li><strong>Wo klemmt es eigentlich derzeit?</strong></li>
<li><strong>Macht es Sinn die DORAâ€‘Baselines zu</strong> messen?</li>
</ol>
<h2>5â€¯|â€¯Fazit</h2>
<p>Ein internes Developerâ€‘Platformâ€‘Team ist <strong>kein Sonderâ€‘Opsâ€‘Team</strong>, sondern ein <strong>Produktâ€‘Team</strong> mit klarer Vision, fokussiertem Scope und messbarem Impact.
Je einfacher, desto besser â€“ und Vertrauen ist kostbar.</p>
<blockquote><p><em>â€Minimalismus ist King â€“ lÃ¶se die wichtigsten 20â€¯% zuerst, die den Teams 80â€¯% des Schmerzes nehmen.â€œ</em> â€“ Jessicaâ€¯Anderson</p>
</blockquote>

    </section>
    
      <footer>
        <a href="2025/6/devopscon-stolperfallen-beim-aufbau-interner-developer-platforms-idp/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/5/die-freuden-einer-gut-eingerichteten-shell-fzf/">
        Die Freuden einer gut eingerichteten Shell: fzf
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2025-05-07">Wednesday, May 7, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2025/5/die-freuden-einer-gut-eingerichteten-shell-fzf/fzf.png" alt="fzf"></p>
<p>Nachdem es bisher in <a href="../../categories/code/">der Serie</a> um die <a href="../../blog/2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">grundlegende Einrichtung der Shell</a>, <a href="../../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/">einen guten Prompt</a> und <a href="../../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/">funktionierende autoomatische VervollstÃ¤ndigung</a> ging, geht es jetzt eine Weile um Werkzeuge um mit der Shell effizient zu navigieren und Dateien und Inhalte zu finden.</p>
<h2>Einleitung</h2>
<p>Hier geht es mir darum das die Arbeit auf der Shell (auf dem eigenen Rechner vor allem) nur dann schnell und Effizient ist, wenn man schnel und einfach in die Ordner kommt in denen man arbeiten mÃ¶chte, und die Dateien findet in denen etwas interessantes steht das man entweder lesen oder verÃ¤ndern mÃ¶chte.</p>
<p>Und natÃ¼rlich ist das Skillset auch auf beliebige Server transferierbar, weil man alle diese Werkzeuge (oder deren etwas primitivere Variante, dazu spÃ¤ter mehr) auch auf einem Server, oder in einem Docker-Container, gerne auch auf einem Kubernetes-Cluster in Produktion einsetzen kann, wo man sonst halt nicht so viele Werkzeuge hat, und schon gar nicht seine IDE anschlieÃŸen kann um zu versuchen dort Herr der Lage zu werden.</p>
<p>Dazu mÃ¶chte ich euch die Tools <a href="https://github.com/ajeetdsouza/zoxide">zoxide</a>, grep/<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>, <a href="https://github.com/junegunn/fzf">fzf</a>, less/cat/<a href="https://github.com/sharkdp/bat">bat</a> und <a href="https://direnv.net">direnv</a> vorstellen.</p>
<p>Diese Tools erleichtern viele tÃ¤glich oft wiederholte ArbeitsablÃ¤ufe dramatisch, und sie ermÃ¶glichen viele Use-Cases, die viele grafischen IDEs und Text-Editoren gar nicht unterstÃ¼tzen. Los geht es mit dem flauschigsten der Tools, fzf.</p>
<h2>Zackig die richtige Datei finden: fzf</h2>
<p><a href="https://github.com/junegunn/fzf">fzf</a> frei Eingezangendeutscht "der flauschige Kommandozeilen Finder", ist ein werkzeug um Dateien (aber auch beliebige andere Dinge) anhand von teilen des Namens oder Mustern wie jeder erste Buchstabe der WÃ¶rter ihres Namens zu finden. Dazu bietet dieses Werkzeug eine OberflÃ¤che die interaktiv die Liste der AuswahlmÃ¶glichkeiten filtert wÃ¤hrend man tippt. Die meisten IDEs bieten so eine Funktion irgendwo mehr oder weniger gut versteckt an, und dieses Werkzeug portiert diese FunktionalitÃ¤t als generisches Werkzeug in die Shell.</p>
<p>Als beispiel: Ich mÃ¶chte einen bestimmten UnitTest ausfÃ¼hren:</p>
<div class="hll"><pre><span></span>$<span class="w"> </span>bin/run_tests_in_docker.sh<span class="w"> </span><span class="k">$(</span>fzf<span class="k">)</span>
</pre></div>
<p>Mit diesem Kommando, wird zuerst fzf aufgerufen (wegen <code>$(fzf)</code>) was dann eine oberflÃ¤che prÃ¤sentiert, mit der man interktiv die richtige oder die richtigen Dateien auswÃ¤hlen kann.</p>
<div class="hll"><pre><span></span><span class="c"># ich verwende die fish shell, daher brauch ich das $ nicht</span>
â¯ bin/run_tests_in_docker.sh <span class="o">(</span>fzf<span class="o">)</span>
  src/models/dokumente/tests/document_distribution_test.py
  src/controller/process_distribution/tests/models_test.py
  src/models/dokumente/tests/dokumente_test.py
  src/integration/d3/api/test/models_test.py
â–Œ src/models/tests/kontaktdaten_test.py
  5/448 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<span class="o">&gt;</span> models <span class="err">&#39;</span><span class="k">test</span>.py
</pre></div>
<p>In dem Interface kann man auch mit den Pfeiltasten navigieren, oder einen Eintrag anklicken. Der von mir eingegebene Suchstring "models 'test.py" bedeutet, dass 'models' irgendwo in dem Treffer diese Buchstaben in dieser Reihenfolge vorkommen mÃ¼ssen, wÃ¤hrend "'test.py" erzwingt das der exakte String 'test.py' vorkommen muss.</p>
<p><a href="https://junegunn.github.io/fzf/shell-integration/">Wenn man die fzf-Integration mit der eigenen Shell aktiviert</a>, kriegt man viele weitere Integrationen in die Shell dazu. Zwei Beispiele:</p>
<ul>
<li><p><code>âŒƒ-T</code> sucht (mit Vorschau!) nach Dateien unterhalb des aktuellen Verzeichnisses. Das ist immer dann Praktisch wenn man fÃ¼r ein Kommando eine Datei aus dem aktuellen Projekt als Argument Ã¼bergeben muss, und spart das tippen von <code>$(fzf)</code>. Klar, mit Auto-VervollstÃ¤ndigung kommt man auch ans Ziel, aber das ist <em>soo</em> viel schneller. Insbesondere wenn man nicht genau im Kopf hat wo die Datei liegt, aber noch weiÃŸ was in Ihrem Namen oder Pfad vorkommen muss. Das verwende ich die ganze Zeit.</p>
</li>
<li><p><code>âŒƒ-R</code> sucht mit <code>fzf</code> in der Shell-Historie. Das funktioniert viel besser als die Standard-Suche, die nur nach direkt zusammenhÃ¤ngenden Buchstaben suchen kann. Ein Beispiel: Das Wenn ich das Kommando <code>helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml | yq</code> aus meiner historie suchen mÃ¶chte, mÃ¼sste ich ohne <code>fzf</code> den exakten Text schreiben der in dem Kommando vorkommt.</p>
</li>
</ul>
<div class="hll"><pre><span></span>~
Search History&gt; helmtemplateexten
  76/32637 <span class="o">(</span>0<span class="o">)</span>
  02-17 18:07:03 â”‚ helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml
  02-17 18:06:10 â”‚ helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml <span class="o">|</span> yq
  02-17 17:59:53 â”‚ helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
  02-17 20:22:18 â”‚ helm template  extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml
  02-17 18:15:27 â”‚ helm template --debug extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml
  02-17 17:59:42 â”‚ helm template --dry-run --debug extensions ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
â–Œ 02-17 17:59:29 â”‚ helm template --dry-run --debug  ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
  02-17 17:59:36 â”‚ helm template --dry-run --debug foo ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ helm template --dry-run --debug ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml  â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
</pre></div>
<p>Wenn ich oft, wenn ich ein neues Terminal Ã¶ffne in die gleichen Projekte navigiere, dann geht das prima Ã¼ber die Shell-History:</p>
<div class="hll"><pre><span></span>â¯ <span class="c"># ctrl-r fÃ¼r history suche</span>
Search History&gt; cdmkkapi
  352/32638 <span class="o">(</span>0<span class="o">)</span> â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  08-12 11:56:19 â”‚ <span class="k">cd</span> mkk/api
  08-24 19:05:13 â”‚ <span class="k">cd</span> ../mkk/api
â–Œ 05-26 08:39:19 â”‚ <span class="k">cd</span> Code/Projekte/mkk/api
  07-29 17:02:48 â”‚ <span class="k">cd</span> Code/Projekte/mkk/api_infra/
  02-15 08:37:01 â”‚ <span class="k">cd</span> Code/Projekte/mkk/api_infra/monitoring/
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ <span class="k">cd</span> Code/Projekte/mkk/api â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
</pre></div>
<p>Mit <a href="https://github.com/ajeetdsouza/zoxide">Zoxide</a> geht das noch besser, aber dazu spÃ¤ter mehr.</p>
<p>So habe ich meine fzf Integration konfiguriert:</p>
<div class="hll"><pre><span></span><span class="c"># configure key-bindings for fzf-fish</span>
<span class="c"># ctrl-f directory search</span>
<span class="c"># ctrl-r history search</span>
<span class="c"># ctlr-v variables search</span>
<span class="c"># ctrl-l git log search</span>
<span class="c"># ctrl-s git status search</span>
<span class="c"># ctrl-p processes pid search</span>
fzf_configure_bindings --git_log<span class="o">=</span><span class="se">\f</span> --directory<span class="o">=</span><span class="se">\c</span>F --git_status<span class="o">=</span><span class="se">\c</span>S --processes<span class="o">=</span><span class="se">\c</span>P
</pre></div>
<p>Das geniale an fzf ist, dass es sich so wunderbar in andere Tools integrieren lÃ¤sst. Hat man es installiert wird es z.B. von <a href="https://github.com/ahmetb/kubectx">KubeCTX</a> verwendet um in <code>kubectx</code> die liste der verbundenen Kubernetes Cluster zu filtern. Oder von <code>kubens</code> um die Liste der Namespaces. TatsÃ¤chlich verwenden viele Werkzeuge intern <code>fzf</code> wenn es instaliert ist. FÃ¼r mich immer wieder eine schÃ¶ne Ãœberrachung, wenn ein weiteres Werkzeug das ich gerne einsetze <code>fzf</code> verwendet.</p>

    </section>
    
      <footer>
        <a href="2025/5/die-freuden-einer-gut-eingerichteten-shell-fzf/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/">
        Die Freuden einer gut eingerichteten Shell: Autocomplete
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2025-04-14">Monday, April 14, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <h2>Was ist schlechte VervollstÃ¤ndigung?</h2>
<p>Um zu verstehen was ich mit guter Auto-Completion fÃ¼r Shells meine, brauchen wir erst einmal eine Baseline wie eine schlechte Completion aussieht. Das lÃ¤sst sich sehr gut mit Docker demonstrieren:Â </p>
<div class="hll"><pre><span></span>docker<span class="w">Â </span>run<span class="w"> </span>--rm<span class="w"> </span>-it<span class="w"> </span>--hostname<span class="w"> </span>shell-completion-demo<span class="w"> </span>debian
</pre></div>
<p>Erstes Experiment: <code>lsâ‡¥â‡¥</code> (kein Leerzeichen vor den Tabs!)</p>
<p><img src="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-commands-unconfigured.png" alt="Automatische VervollstÃ¤ndigung von Kommandos - unkonfiguriert"></p>
<p>Zeigt alle Kommandos die mit <code>ls</code> anfangen
Zweites Experiment: <code>ls â‡¥â‡¥</code>
Das zeigt bei mir:</p>
<p><img src="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-files-unconfigured.png" alt="Automatische VervollstÃ¤ndigung von Dateien - unkonfiguriert"></p>
<p>Schon mal gut, denn hier werden die Dateien im aktuellen Ordner vervollstÃ¤ndigt.</p>
<p>NÃ¤chste Schwierigkeitsstufe - kurze und lange Optionen: <code>ls -â‡¥â‡¥</code> (Minus vor dem Tab)
Das zeigt hier nichts, genauso fÃ¼r lange OptionenÂ <code>ls --â‡¥â‡¥</code> (zwei mal Minus vor dem Tab)</p>
<p>Keine Ausgabe. <code>ls</code> ist eigentlich so ungefÃ¤hr dasÂ einfachste Programm das jeder Shell beiliegt. Wenn automatische VervollstÃ¤ndigung also irgend etwas kann, dann sollte <code>ls</code> gut funktionieren.</p>
<h2>Was ist gute VervollstÃ¤ndigung?</h2>
<p>Dagegen mal ein Beispiel von meinem System:</p>
<p><code>lsâ‡¥</code> zeigt die Kommandos die mit ls anfangen, mit einer Kurzbeschreibung was diese Kommandos tun.</p>
<p><img src="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-commands-configured.png" alt="VervollstÃ¤ndigung von Kommandos mit der Fish-Shell"></p>
<p>Schon mit einem Tab sehe ich die Dateien, und zusÃ¤tzlich sehe ich als Vorschlag den letzten Befehl den ich mit <code>ls</code> abgesetzt habe und kann diesen mit <code>âŒƒâ†’</code> im ganzen, oder mit  <code>â†’</code> wortweise akzeptieren kann.</p>
<p><img src="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-files-configured.png" alt="Automatische VervollstÃ¤ndigung von Dateien mit der Fish Shell"></p>
<p>Ein ls -â‡¥<code>ergibt sofort eine Optionsliste - kurz und lang - mit einer Kurzbeschreibung was dieses Schalter tun. Ein zweites Minus und Tab</code>ls --â‡¥` zeigt nur noch die langen Optionen an:</p>
<p><img src="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-options-configured.png" alt="VervollstÃ¤ndigung von Optionen mit der Fish-Shell">
<img src="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-long-options-configured.png" alt="VervollstÃ¤ndigung von langen Optionen mit der Fish-Shell"></p>
<p>NatÃ¼rlich kann ich mit den Pfeiltasten oder mit Tab eine der Optionen auswÃ¤hlen - natÃ¼rlich mit ordentlichem Highlighting.
So macht arbeiten auf der Shell SpaÃŸ!</p>
<p>Falls Ihr verwirrt seid das mein ls andere Optionen anbietet als eures, dann liegt das daran <a href="https://github.com/ogham/exa">das ich ls durch exa ersetzt habe</a>.</p>
<h2>Wie kÃ¶nnt Ihr das bei euch nutzen?</h2>
<p>Ich nutze die <a href="https://fishshell.com">Fish-Shell</a>, da diese von Haus aus eine sehr gute Autocompletion anbietet. Das ist aber nicht fÃ¼r jede, denn die Syntax der Fish Shell ist etwas anders als bei Bash/ZSH - eben nicht posix kompatibel. Ich mag das Weil es logischer und KÃ¼rzer ist, aber ich komme auch nicht durcheinander mit den verschiedenen Shell-Syntaxen da ich sie schon so lange verwende.</p>
<p>Fast alle Shell Konfigrurations-Frameworks wie <a href="https://ohmyz.sh">oh-my-zsh</a> oder <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> bieten zumindest etwas an das diesem Nahe kommen. Alle automatische Konfiguration stÃ¶ÃŸt aber irgendwann an Ihre Grenzen wenn es um die Kommandos geht, die wir tÃ¤glich benutzen. <code>docker</code> vervollstÃ¤ndigt dann nicht compose und oder kennt die Unterkommandos davon nicht oder nur unvollstÃ¤ndig, kubectl und helm sind notorische Kandidaten fÃ¼r die man sich selber kÃ¼mmern muss.</p>
<p>Jetzt kÃ¶nnte man natÃ¼rlich versuchen automatisch aus der Hilfsausgabe dieser Kommandos etwas zu generieren (das macht z.B. die Fish shell von sich aus) oder man schreibt selber etwas (argh).</p>
<p>Oder man wendet sich vertrauensvoll an das tool <a href="https://github.com/carapace-sh/carapace">carapace</a>, mit dem man die Completion fÃ¼r Programme komfortabel fÃ¼r alle Shells nachrÃ¼sten kann. Als Beispiel um die die Autocompletions fÃ¼r kubectl nachzurÃ¼sten, einfachÂ <code>source &lt;(carapace kubectl zsh)</code> oder <code>carapace kubectl fish | source</code> (je nach shell) eingeben und ausprobieren ob es gefÃ¤llt, und wenn ja, diese Zeile in die User-Konfiguration deiner shell eintragen und viel glÃ¼cklicher sein.</p>
<p>Obacht: Man kann mit so einem Snippet</p>
<div class="hll"><pre><span></span><span class="c1"># ~/.zshrcÂ </span>
<span class="nb">export</span><span class="w"> </span><span class="nv">CARAPACE_BRIDGES</span><span class="o">=</span><span class="s1">&#39;zsh,fish,bash,inshellisense&#39;</span><span class="w">Â </span><span class="c1"># optional</span>
zstyle<span class="w"> </span><span class="s1">&#39;:completion:*&#39;</span><span class="w"> </span>format<span class="w"> </span><span class="s1">$&#39;\e[2;37mCompleting %d\e[m&#39;</span>
<span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>carapace<span class="w"> </span>_carapace<span class="o">)</span>
</pre></div>
<p>in seinerÂ Shell-Konfiguration alle completer des Carapace Projekts aktivieren. Das hat mir allerdings nicht gefallen,, da ich manche der eingebauten Completer der Fish-Shell noch etwas besser finde als das was Carapace bereit stellt. Aber um LÃ¼cken zu ergÃ¤nzen? Perfekt!</p>
<p>Meine Shell-Completion Konfiguration (fish!) sieht daher so aus:</p>
<div class="hll"><pre><span></span><span class="c"># enable shell completions</span>
<span class="k">set</span> --global --export CARAPACE_BRIDGES <span class="s1">&#39;zsh,fish,bash,inshellisense&#39;</span>
<span class="c"># I didn&#39;t have much luck enabling all carapace completions, but I do like some of them - especially if there is no built in fish completion for them</span>
<span class="c"># carapace _carapace | source</span>
carapace fd <span class="o">|</span> <span class="nb">source</span>
carapace bat <span class="o">|</span> <span class="nb">source</span>
carapace brew <span class="o">|</span> <span class="nb">source</span>
carapace rg <span class="o">|</span> <span class="nb">source</span>
carapace docker <span class="o">|</span> <span class="nb">source</span>
uv generate-shell-completion <span class="nb">fish</span> <span class="o">|</span> <span class="nb">source</span>
yq completion <span class="nb">fish</span> <span class="o">|</span> <span class="nb">source</span>
</pre></div>

    </section>
    
      <footer>
        <a href="2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/">
        Die Freuden einer gut eingerichteten Shell: Der Prompt
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2025-02-27">Thursday, February 27, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/terminal.jpg" alt="Terminal"></p>
<p>Es fÃ¤ngt natÃ¼rlich mit der Frage an: welche Shell?</p>
<p>Das ist sehr einfach zu beantworten. Auf MacOS ist die <a href="https://www.zsh.org">zsh</a> die Standard-Shell - und daher sollte man die auch benutzen. Artikel Fertig, vielen Dank fÃ¼rs Lesen! ğŸ˜…</p>
<p>Windows hat die <a href="https://de.wikipedia.org/wiki/PowerShell">PowerShell</a> - wer damit Arbeiten (muss) sollte sie lernen!</p>
<p>Die nackte Shell ist ziemlich schlecht konfiguriert, da die MÃ¶glichkeiten der Shell gar nicht ausgenutzt werden. Auf Linux-Distributionen ist es Standard, dass die Shell von der Distribution eingerichtet wird, daher kann man damit meistens schon gut arbeiten.</p>
<p>Aber fÃ¼r MacOS (und Windows) gibt es viel zu tun.</p>
<p>So sieht die zsh unkonfiguriert aus:</p>
<div class="hll"><pre><span></span>dwt@NB1321<span class="w"> </span>~<span class="w"> </span>%<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>Library/Favorites
dwt@NB1321<span class="w"> </span>Favorites<span class="w"> </span>%
</pre></div>
<p>Das ist schon gar nicht schlecht, denn man sieht einiges:</p>
<ul>
<li><code>dwt</code>: Welcher Nutzer man gerade ist. Wichtig, wenn man viel mit <code>sudo</code> arbeitet, damit man nicht versehentlich Kommandos als <code>root</code> mit zu vielen Rechten ausfÃ¼hrt.</li>
<li><code>NB1321</code>: Auf welchem Rechner man gerade eingeloggt ist. Wichtig wenn man auf vielen Rechnern arbeitet und nicht</li>
<li>Den aktuellen Ordner in dem man ist (<code>Favorites</code>). Wichtig damit man z.B. nicht versehentlich die falschen Dateien lÃ¶scht.</li>
<li>Der Prompt <code>%</code> trennt die Meta-Informationen von dem was man selbst eingibt.</li>
</ul>
<p>Da geht aber noch wesentlich mehr. Bei mir z.B. sieht der Prompt so aus:</p>
<div class="hll"><pre><span></span>~/C/P/m/api<span class="w"> </span>â„ï¸<span class="w"> </span>ğŸ§ª<span class="w"> </span>nix-shell-env<span class="w">   </span>ğŸ<span class="w"> </span>venv<span class="w"> </span>â›µï¸<span class="w"> </span>mkk-itsc-dev<span class="w"> </span><span class="o">(</span>api<span class="o">)</span><span class="w"> </span>ğŸŒ±<span class="w"> </span>main<span class="w"> </span><span class="nv">$!</span><span class="w">  </span>4s
â¯
</pre></div>
<p>Da ist enthalten:</p>
<ul>
<li><code>~/C/P/m/api</code> - nicht nur der aktuelle Ordner, sondern auch jeweils der Anfangsbuchstabe der darÃ¼ber liegenden Ordner. Das liefert platzsparend viel mehr Kontext, wo man gerade ist. Super wenn man in vielen Projekten gleichnamige Ordner wie z.B. <code>etc</code>, <code>src</code> oder <code>dist</code> hat.</li>
<li><code>â„ï¸ ğŸ§ª nix-shell-env</code> Zeigt an, dass gerade eine 'dreckige' <a href="https://nixos.wiki/wiki/Development_environment_with_nix-shell">Nix-Shell</a> aktiv ist. Das verwende ich um Projek-spezifische AbhÃ¤ngigkeiten (Shell-Tools, bestimmte Vesionen von Python etc.) zu installieren die ich deklarativ im Projekt tracke. Gut vergleichbar mit Python-Virtual-Envs - aber eben fÃ¼r alles, nicht nur Python-Pakete. Dreckig ('impure') ist Sie, da nicht <em>nur</em> die Shell-Tools aus der Nix-Shell sichtbar sind, sondern auch alles andere was ich im Betriebsystem installiert habe.</li>
<li><code>ğŸ venv</code> - zeigt an, dass gerade ein Python-Virtual-Env aktiv ist. Da ich hauptsÃ¤chlich mit Pyton entwickle ist das natÃ¼rlich entscheidend weil es bedeutet das ich die Projekt-Werkzeuge direkt verwenden kann, da sie im <code>$PATH</code> und <code>$PYTHONPATH</code> sind.</li>
<li><code>â›µï¸ mkk-itsc-dev (api)</code> zeigt an, dass ich mit dem <code>mkk-itsc-dev</code> Kubernetes Cluster verbunden bin, und den Namespace <code>api</code> aktiviert habe. Das ist mir sehr wichtig, damit ich nicht versehentlich mit <code>kubectl</code> Befehlen versehentlich den Produktiv-Cluster zerstÃ¶re. (Rate wieso mir das so wichtig istâ€¦)</li>
<li><code>ğŸŒ± main $!</code> zeigt an, dass ich in einem Git-Repository bin, auf dem main branch, das ich dinge ge-'stash't habe (die vergisst man sonst sehr leicht) und das ich Ã„nderungen habe die ich noch nicht commited habe. Hier gibt es <a href="https://starship.rs/config/#git-status">auch noch mehr informationen wenn das Repo den entsprechenden Zustand hat</a>.</li>
<li>Zuletzt sehe ich da das letzte Kommando 4 Sekunden gedauert hat. Das wird nur angezeigt wenn das letzte Programm mehr als 3 Sekunden gedauert hat und ist immer wiede ein hilfreiche Information um bei langlaufenden Prozesen zu verstehen ob es sich lohnt da etwas zu optimieren.</li>
</ul>
<p>NatÃ¼rlich kÃ¶nnte man hier noch viel mehr anzeigen, je nachdem an was man gerade arbeitet. Ich habe hier eben die Informationen aufgenommen die ich am meisten benÃ¶tige.</p>
<p>Jetzt kommt der Clou: FrÃ¼her habe ich das alles von hand Konfiguriert. Das war ein ewiges und mÃ¼hsammes gefummel um <code>$PS1</code> und konsorten so hinzufummeln das das alles funktioniert hat, und hat nie SpaÃŸ gemacht. Der Standard ist derzeit, das man einen Shell-Konfigurations-Framework wie <a href="https://ohmyz.sh">Oh-My-Zsh</a> oder <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> verwendet. Und die sind auch gut. Aber auch langsam, und komplex und kompliziert. Wenn man da mal etwas anders haben will dann gott bewahre wenn das nicht schon vorbereitet ist oder man darf sich nicht nur mit den KomplexitÃ¤ten von <code>$PS1</code> auseinandersetzen, sondern auch noch damit wie genau dieser Framework das handhabt.</p>
<p>Inzwischen bin ich weiser geworden, und verwende <a href="https://starship.rs">Starship</a>. Damit kann ich meinen Prompt deklarativ in einer <code>.toml</code>-Datei konfigurieren und diesen auch mitnehmen wenn ich mal die Shell wechsle. (Was hÃ¤ufiger vorkommt als mir lieb ist). Und: Starship funktioniert auch mit der PowerShell.</p>
<p><a href="2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/starship.toml">So sieht meine Konfiguration aus</a></p>
<p>Wie richtet man das ein?</p>
<ol>
<li><code>brew install starship</code> (oder mit <a href="https://lix.systems">nix</a>)</li>
<li><code>nano ~/.zshrc</code> und am Ende <code>eval "$(starship init zsh)"</code> einfÃ¼gen.</li>
<li>Konfigurationsdatei erstellen: <code>nano ~/.config/starship.toml</code> und z.b. <a href="2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/starship.toml">den Inhalt aus der Datei oben einfÃ¼gen</a>.</li>
<li>Shell neu starten oder neues Terminal Ã¶ffnen.</li>
</ol>
<p>Danke sagen fÃ¼r die grandiose Verbesserung eures Shell-Lebens bei mir nicht vergessen. ğŸ˜…</p>

    </section>
    
      <footer>
        <a href="2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/">
        A Nix&#39;le in a BÃ¼chse und a goldigs Warteweile
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2025-02-08">Saturday, February 8, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/nix-rabbit-hole.png" alt="Das Nix Hasenloch">
â€¦ ist ein schwÃ¤bisches Sprichwort und passt gar nicht so schlecht fÃ¼r die vielen schlechten Wortwitze die sich automatisch ergeben, wenn man anfÃ¤ngt, sich in das <a href="https://nix.dev">Nix Projekt</a> einzuarbeiten.</p>
<p>ZunÃ¤chst mal die Karotte mit der ich mich kÃ¶dern lieÃŸ:</p>
<ul>
<li>Deklarative Konfiguration von Software-Builds, System-Konfigurationen, und wenn man mÃ¶chte auch Deployments z.B. in Kubernetes und was man sonst gerne mÃ¶chte</li>
<li>Ein funktionaler Paket-Manager, das heiÃŸt: Jede Software kann ihre eigenen AbhÃ¤ngigkeiten in der passenden Version haben. Wenn ich mal ein Tool in der Version von vor 10 Jahren brauche - einfach zusÃ¤tzlich installieren, ohne dass dadurch etwas gestÃ¶rt wird. Wenn ich mal eine neuere Version von etwas brauche als die aktuelle Distribution anbietet: Einfach installieren, ohne dass dadurch etwas gestÃ¶rt wird.</li>
<li>Rollback: Systemkonfiguration hat etwas kaputt gemacht? Einfach RÃ¼ckgÃ¤ngig machen.</li>
<li>Update auf eine neue Version des Betriebssystems: Man kriegt fehlermeldungen fÃ¼r alle Konfigurationen die man vorgenommen hat die jetzt umbenannt wurden oder anders funktionieren. ğŸ¤¯</li>
<li>Reproduzierbarkeit: VollstÃ¤ndige Erfassung der Inputs und Ablegen derselben in einem Lock-File.</li>
<li>Eine riesige Community, die beste Praktiken zum Betrieb von Linux (und mehr) Systemen <a href="https://repology.org/repositories/statistics/total">in die grÃ¶ÃŸte Software-Bibliothek kodiert, die wir bisher gesehen haben.</a></li>
</ul>
<p>Was sollte man da nicht mÃ¶gen?</p>
<p>Auf MacOs gibt es mit <a href="https://github.com/LnL7/nix-darwin">nix-darwin</a> ein Projekt mit dem man die System-Konfiguration deklarativ vornehmen kann - und auch <a href="https://brew.sh">homebrew</a> (was sonst so gut wie gar nicht reproduzierbar ist) unter Kontrolle kriegt. Und wenn man mÃ¶chte, verwaltet es einem auch die dotfiles.</p>
<p>Es gibt allerdings einen gewaltigen Nachteil: Das Ganze ist echt komplex und kompliziert. Und die Dokumentation ist nicht schlecht, aber kÃ¶nnte deutlich besser sein.</p>
<p>Wenn man diese HÃ¼rde Ã¼berwindet, wird man mit einer erstaunlich kompakten und sehr schnell anzuwendenden System-Konfiguration belohnt. Damit kann man zum Beispiel auf einem Mac ein vollstÃ¤ndig konfiguriertes System-Image fÃ¼r einen Raspberry Pi erstellen. Dann noch flaschen, starten und lÃ¤uft! Oder auf meinem Mac Bauen, und via ssh auf dem RasPi deployen, ohne dort irgendwas zu machen was dessen CPU stresst.</p>
<p>Ich habe inzwischen angefangen, meine Rechner damit zu verwalten und konfigurieren.</p>
<ul>
<li><a href="https://github.com/dwt/nix-darwin-config">Mein Rechner (nix-darwin)</a></li>
<li><a href="https://github.com/dwt/home-servers">Mein Homelab (nixos)</a></li>
<li><a href="https://github.com/dwt/home-automation">Meine Heimautomatisierung (python)</a></li>
</ul>
<h1>Nix ist vielleicht nichts fÃ¼r dichâ€¦</h1>
<p>â€¦ aber wenn Du ein bisschen nerdig bist, und gerne auf der Kommandozeile lebst, infrastruktur as Code magst oder lernen magst und DevOps fÃ¼r dich eh normal ist. Dann kÃ¶nnte Nix auch fÃ¼r dich genau das richtige sein.</p>
<h1>Wie lernt man Nix am besten?</h1>
<p>Was mir beim Lernen von Nix gefehlt hat, wÃ¤re eine Leitlinie gewesen, in welcher Reihenfolge ich mich an die vielen Features von Nix heran tasten sollte. Eine Reihenfolge, die sicherstellt, das die Lernkurve zu jedem Zeitpunkt ertrÃ¤glich bleibt. Und besonders wichtig: Die Sicherstellt, das zu jedem Zeitpunkt sichtbar ist wie cool und wertvoll diese Technologie ist. Sonst lÃ¤uft man Gefahr, ob der steilen Lernkurve abzuspringen.</p>
<p>Das hÃ¤tte ich gerne gehabt: Wenn du anfÃ¤ngst Nix zu lernen, dann am besten in dieser Reihenfolge:</p>
<h2>1. Schritt: Installieren, ohne was bestehendes kaputt zu machen</h2>
<p>Zuerst sollte man Nix neben dem aktuellen OS installieren. Der Standard ist der <a href="https://docs.determinate.systems/getting-started/individuals/">Determinate Installer</a>, aber ich mag <a href="https://lix.systems">das Lix Projekt lieber, da es schneller ist</a>. Alternativ ist auch <a href="https://nixos.org/download/#nix-install-docker">der Nix-Docker-Container super um es mal auszuprobieren</a>. Wenn man mÃ¶chte, <a href="https://nixos.org/download/#nix-install-linux">kann man Nix (auf Linux) auch einfach in einen Ordner installieren und so verwenden (siehe "Single-User Mode")</a>. Das wÃ¼rde ich aber nur fÃ¼r ein paar Experimente empfehlen. Sowohl der Determinate als auch der Lix-Installer haben sehr gute Uninstaller die das Projekt auch wieder komplett entfernen kÃ¶nnen.</p>
<h2>2. Schritt: Imperativ verwenden</h2>
<p>Nix erlaubt es jederzeit ein Paket zu benutzen, ohne es zu installieren. Das ist eine Konsequenz davon wie der Paket-Manager aufgebaut ist. Ein Paket kann 'im <code>/nix/store/</code> sein' - ohne das es aktiv ist. Und der Befehl <code>nix run nixpkgs#fzf</code> startet es dann einfach - ohne es zu installieren. Alternativ gibt es auch <code>nix shell nixpkgs#fzf</code>. Damit erhÃ¤llt man eine Shell, in der <code>fzf</code> installiert ist. SchlieÃŸt man die Shell, ist es auch wieder weg. ğŸ˜³</p>
<p>Dass ist der Hammer, weil man so Pakete ohne Reue ausprobieren kann. Ohne Sorgen, dass doch noch irgendwelche AbhÃ¤ngigkeiten evtl. auf dem System herum gurken und man vergessen kÃ¶nnte ein Experiment wieder zu entfernen. Und das beste: Auch spÃ¤ter wird man dieses Feature die ganze Zeit verwenden.</p>
<p>Vorsicht vor <code>nix-env</code> und <code>nix profile</code> - das ist das Ã„quivalent zu dem wie man mit <code>homebrew</code>  und anderen Paketmanagern Pakete installieren wÃ¼rde. Diese sollte man so selten wie mÃ¶glich verwenden. Besser istâ€¦</p>
<h2>3. Schritt: Entwicklungsumgebungen <code>shell.nix</code></h2>
<p>Das, was <code>nix shell nixpkgs#fzf</code> macht, kann man auch in eine Datei schreiben, und damit einfach in ein Repo mit einchecken. Schon hat man Deklarativ die ganzen Tools im Repo dokumentiert, die man braucht um mit einem Projekt zu arbeiten. Bonus: Ich kann fÃ¼r jedes Projekt eigene Versionen der AbhÃ¤ngigkeiten haben (wenn ich das brauche). Python-Virtual-Envs auf Steroiden!</p>
<p>Hier ein Beispiel:</p>
<div class="hll"><pre><span></span><span class="p">{</span>
  pkgs <span class="o">?</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{</span> <span class="p">},</span>
<span class="p">}:</span>
pkgs<span class="o">.</span>mkShell <span class="p">{</span>
  <span class="ss">buildInputs</span> <span class="o">=</span> <span class="k">with</span> pkgs<span class="p">;</span> <span class="p">[</span>
    <span class="c1"># Add your build inputs here</span>
    pkgs<span class="o">.</span>python313
    pkgs<span class="o">.</span>uv
  <span class="p">];</span>
  <span class="ss">env</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">UV_PYTHON</span> <span class="o">=</span> pkgs<span class="o">.</span>python313<span class="p">;</span>
    <span class="ss">UV_DOWNLOAD_PYTHON</span> <span class="o">=</span> <span class="s2">&quot;never&quot;</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>Wenn man das mit <code>nix-shell</code> aufruft, dann hat man diese Python-Version zur Hand. <code>uv</code> verwendet diese und lÃ¤dt selber keine Python-Versionen herunter. Nice! Extra nice: mit <code>nix-shell --pure</code>  hat man eine Shell in der <em>nur</em> das sichtbar ist was in dem <code>shell.nix</code> steht, und man kriegt Fehler fÃ¼r alles was man verwendet und in der <code>shell.nix</code> vergessen hat. ğŸ¤¯</p>
<p>Bonus: <a href="https://direnv.net">Direnv</a> verwenden um automatisch die <code>shell.nix</code> und das <code>.env</code> zu laden. Dazu <a href="https://github.com/ajeetdsouza/zoxide">zoxide</a> um schnell in der Shell zwischen vielen Projekten hin und zu springen. Eine richtig geniale Entwicklungsumgebung.</p>
<p>Ich empfehle erst mal eine weile auf diesem Niveau zu bleiben, denn das ist schon ziemlich cool!</p>
<h2>4. Schritt: Mehr Tooling um besser mit Nix klar zu kommen</h2>
<ul>
<li>Pakete findet man am besten Ã¼ber <a href="https://search.nixos.org/packages">die Webseite search.nixos.org</a> - aber ich mag eigentlich in der shell suchen. <code>nix run nixpkgs#nh search ut1999</code> funktioniert besser als alles was ich sonst bisher getestet habe.</li>
<li>Anzeigen was gerade installiert ist und wieso ist aufgrund der Architektur von nix gar nicht so einfach. <code>nix run nixpkgs#nix-tree</code> aproximiert das und gibt einen guten Ã¼berblick darÃ¼ber was man auf dem System hat.</li>
<li><code>nom</code> - der <a href="https://github.com/maralorn/nix-output-monitor">Nix-Output-Monitor</a> <code>nix run nixpkgs#nix-output-monitor</code> macht den output von lÃ¤ngeren nix builds viel informativer und spannender. Verwenden kann man das so: <code>nix run $something |&amp; nix run nixpkgs#nix-output-monitor</code></li>
<li><code>nix store gc</code> um alles zu lÃ¶schen, was man mal testweise runtergeladen hat und nicht mehr auf der Platte braucht. (Einer Der Nachteile von Nix: Es verbraucht schnell <em>viel</em> Plattenplatz).</li>
</ul>
<h2>5. Schritt: Tief in das Hasenloch fallen</h2>
<p>Jetzt gibt es verschiedene Sachen die man sich anschauen kÃ¶nnte</p>
<ul>
<li><a href="https://nix.dev/manual/nix/2.24/language/index.html">Die Nix Sprache lernen</a> - die Voraussetzung fÃ¼r fast alles was danach kommt, also gut investierte Zeit. Und es ist eine wirklich kleine Sprache - auch wenn <a href="https://github.com/NixOS/nixpkgs">die 'Standard-Bibliothek' (meiner Meinung nach das NixPKGs Repository)</a> alles andere als klein ist.</li>
<li><a href="https://devenv.sh">devenv</a> um Entwicklungsumgebungen kurz und Knackig und mit allen Features deklarativ zu beschreiben und ins Projekt eingecheckt zu bekommen.</li>
<li><a href="https://nixos-and-flakes.thiscute.world">Flakes - der Standard in der Nix-Community, mit der AbhÃ¤ngigkeits-Versionen festgeschrieben werden</a>. Also wie checke ich die genauen git commit hashes die ich verwendet habe um alle meine Software zu bauen ins Repo mit ein. Damit kann man ein Projekt auch nach Jahren sehr einfach verlÃ¤sslich wieder bauen.</li>
<li><a href="https://github.com/pyproject-nix/uv2nix">uv2nix - wie man Python-Projekte Nix-ifiziert</a></li>
<li><a href="https://github.com/LnL7/nix-darwin">nix-darwin</a> um ein MacOS System so deklarativ zu verwalten, wie das unter NixOS geht. (OK, Apple setzt da grenzen, aber das ist trotzdem sehr cool).</li>
<li><a href="https://nix-community.github.io/home-manager/">home-manager</a> um dotfiles zu verwalten und auf Benutzer-Ebene alles zu konfigurieren.</li>
<li>Quasi alles von <a href="https://github.com/nix-community/awesome-nix?tab=readme-ov-file">Awesome-Nix</a>.</li>
<li>Und so viele Projekte mehr, die man sich anschauen kÃ¶nnteâ€¦</li>
</ul>

    </section>
    
      <footer>
        <a href="2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">
        Grundlegende Funktionen und Einstellungen des Terminals
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2024-11-25">Monday, November 25, 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p>Der Terminal-Emulator ist ein zentrales Werkzeug, mit dem wir Entwickler mit unseren Rechnern interagieren. Jedes bisschen Wissen und jede Effizienz, die du hier gewinnst, zahlt sich in kÃ¼rzester Zeit hundertfach aus.</p>
<p>NatÃ¼rlich gibt es viele Terminals, wie <a href="https://iterm2.com">iTerm2</a>, <a href="https://alacritty.org">Alacritty</a> oder <a href="https://sw.kovidgoyal.net/kitty/">Kitty</a>. Aber ich finde, diese solltest du nur verwenden, wenn sie deinen Workflow wirklich verbessern. Und dafÃ¼r musst du zuerst wissen, was Apple standardmÃ¤ÃŸig mitliefert.</p>
<p>Das SchÃ¶ne am Terminal ist, dass du unglaublich wenig anpassen musst, da es von Haus aus sehr gut funktioniert.</p>
<p>Ich nutze das eingebaute Terminal von macOS mit nur zwei (!) Konfigurationsanpassungen.</p>
<h2>Wortweise LÃ¶schen</h2>
<p><img src="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/delete-word.png" alt="Wortweise LÃ¶schen"></p>
<p>Die erste wirklich wichtige Anpassung fÃ¼r mich ist, dass âŒ¥-âŒ« (Alt-Delete) als Standard-Keybinding gesetzt wird, damit wortweise nach links gelÃ¶scht wird. Damit passt du das Terminal an den Mac-Standard an, der in fast allen anderen Programmen ebenfalls funktioniert.</p>
<p>So geht's:</p>
<ol>
<li>Terminal â†’ Einstellungen Ã¶ffnen (âŒ˜-,).</li>
<li>Auf der linken Seite alle Profile auswÃ¤hlen, damit alle Einstellungen gleichzeitig bearbeitet werden.</li>
<li>Auf der rechten Seite â†’ "Tastatur" auswÃ¤hlen.</li>
<li>Einen neuen Shortcut hinzufÃ¼gen.</li>
<li>Die Felder wie im Screenshot ausfÃ¼llen. <code>\027</code> steht fÃ¼r <strong>âŒƒ-w</strong> (<code>ctrl-w</code>), den Standard-Shortcut fÃ¼r wortweises LÃ¶schen in der Shell.</li>
</ol>
<h2>Ausgabe navigieren, selektieren und lÃ¶schen</h2>
<p>Die nÃ¤chst-wichtigsten Shortcuts sind:</p>
<ul>
<li><strong>âŒ˜-N</strong> / <strong>âŒ˜-T</strong> / <strong>âŒ˜-W:</strong> Alles Standard, aber trotzdem meine meistbenutzten Shortcuts.</li>
<li><strong>âŒ˜-â†‘</strong> und <strong>âŒ˜-â†“:</strong> Zum Anfang des vorherigen bzw. nÃ¤chsten ausgefÃ¼hrten Befehls springen. Das ist super praktisch, um schnell nachzusehen, was die vorherigen Kommandos waren.</li>
<li><strong>âŒ˜-Shift-â†‘</strong> und <strong>âŒ˜-Shift-â†“:</strong> Wie oben, aber selektiert zusÃ¤tzlich. Damit kannst du schnell einen Befehl und dessen Ausgabe kopieren. Das ist super praktisch, um Anleitungen zu schreiben oder einem Kollegen zu zeigen, wie etwas gemacht wurde.</li>
<li><strong>âŒ˜-L:</strong> LÃ¶scht nur die Ausgabe des letzten Kommandos. Sehr praktisch, um ein nicht mehr benÃ¶tigtes Shell-Experiment zu entfernen â€“ besonders bei Fehlern mit viel Output. Oft nutze ich das, wenn ich zuerst eine Hilfe anzeige und dann darunter verschiedene Experimente ausfÃ¼hre, um die richtigen Flags zu finden. (Genauer: <strong>âŒ˜-L</strong> lÃ¶scht vom Ende bis zur aktuellen Selektion und funktioniert daher hervorragend mit <strong>âŒ˜-â†‘</strong>.)</li>
<li><strong>âŒ˜-K:</strong> Terminal lÃ¶schen. Die nukleare Option â€“ sie lÃ¶scht alles im aktuellen Terminal. GroÃŸer Nachteil: Was weg ist, ist weg. Also nicht benutzen, wenn du den Output noch brauchst. Dennoch ist dies einer meiner am hÃ¤ufigsten benutzten Shortcuts.</li>
</ul>
<h2>Unbegrenzter Puffer</h2>
<p><img src="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/unlimited-buffer.png" alt="Unbegrenzter Puffer"></p>
<p>Die zweite Anpassung, die ich vornehme, ist, den Scrollback-Puffer auf unbegrenzt zu stellen, damit ich die Ausgabe von langen Kommandos nicht verliere. Das geht so:</p>
<ol>
<li>Terminal â†’ Einstellungen Ã¶ffnen (<strong>âŒ˜-,</strong>).</li>
<li>Wie zuvor alle Profile auswÃ¤hlen.</li>
<li>Auf der rechten Seite â†’ "Fenster" â†’ "Zeilenpuffer" auf â€auf den verfÃ¼gbaren Speicher begrenzenâ€œ stellen.</li>
</ol>
<h2>Fazit</h2>
<p>Mit diesen Shortcuts kannst du ultraschnell zwischen den letzten Kommandos navigieren, deren Ausgabe selektieren (und kopieren) oder lÃ¶schen.</p>
<p>Diese Anpassungen und Shortcuts sind fÃ¼r mich auch einer der HauptgrÃ¼nde, warum ich die eingebauten Terminals in IDEs nicht gerne benutze. Denn dort funktionieren sie oftmals nicht gut.</p>
<p>Viele dieser Einstellungen und Shortcuts gibt es auch auf der Ebene der Shell. Der Vorteil, sie Ã¼ber das Terminal zu konfigurieren, ist, dass diese Shortcuts auch auf anderen Servern oder in Docker- bzw. Kubernetes-Containern funktionieren.</p>
<p>Ich hoffe, diese Tipps helfen dir, das Terminal noch besser zu nutzen.</p>
<p>Kennst du weitere nÃ¼tzliche Shortcuts oder Einstellungen, die ich nicht erwÃ¤hnt habe? Hast du Fragen zu den vorgestellten Tipps? Lass es mich wissen!</p>
<p>Happy Shelling!</p>

    </section>
    
      <footer>
        <a href="2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/">
        Wie kann KI beim Lernen mit Blooms-Taxonomie unterstÃ¼tzen?
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2024-10-10">Thursday, October 10, 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/bloom.jpeg" alt="Blooms Taxonomie"></p>
<p>Nachem ich jetzt lange <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">Ã¼ber Blooms Taxonomie</a> und <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">was die Ebenen</a> <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">im Detail bedeuten</a> geschrieben habe, kann ich jetzt <em>endlich</em> zu dem kommen, was mir eigentlich am Herzen liegt:</p>
<p>Mein ganzes Leben lang haben andere die Ebenen von Blooms Taxonomie verwendet um zu beurteilen wie gut ich etwas verstanden habe - aber man kann diesen SpieÃŸ auch umdrehen, und das wissen um diese Ebenen des VerstÃ¤ndnisses nutzen um selbst besser zu lernen! (Ehrlich gesagt, bin ich ziemlich angepisst das mir das nicht von Vorne herein genau dafÃ¼r erklÃ¤rt und beigebracht wurde)</p>
<p>Wie funktioniert das? Wenn Mensch ohne Plan lernt, dann neigen wir dazu uns zunÃ¤chst auf den unteren Ebenen zu bewegen. Denn das ist (vermeintlich) einfacher und erscheint logisch. Aber aus der Forschung wissen wir, dass sich von vorne herein auf Fragen der 4. und 5. Ebene (also Analysieren und Bewerten) zu konzentrieren, nicht nur schneller, sondern auch tieferes VerstÃ¤ndnis bringt.</p>
<p>Warum? Weil sich die Art und Weise verÃ¤ndert mit der wir uns mit dem Lern-Material beschÃ¤ftigen. Auswendig Lernen ist ja nicht verzichtbar. Man muss sich die Fakten ja merken. Aber das passiert auch, wenn man sie Analysiert und Bewertet - ABER - wir kriegen die Analyse und Bewertung gratis dazu. (Wohlgemerkt, fÃ¼r etwas mehr Kognitive Anstrengung, aber Entspannung ist ja nicht das Ziel.)</p>
<p>Und das ist der Clou. Gleicher Zeiteinsatz, aber tieferes VerstÃ¤ndnis.</p>
<p>ğŸ¤¯</p>
<p>Jetzt ist natÃ¼rlich nicht jeder mit der FÃ¤higkeit geboren, sich selbst einfach so Fragen auf der 4. und 5. Ebene zu stellen. Aber das ist auch gar nicht nÃ¶tig. Denn KI kann dabei prima helfen.</p>
<p>Chat-GPT hat ein sehr gutes VerstÃ¤ndnis von Blooms-Modell und kann endlos fragen auf Bloom Level 4 und 5 zu jedem Thema generieren. Die sind nicht immer perfekt, es reicht aber, um sich darauf einzustimmnen wie solche Fragen aussehen und effizient selbst zu solchen Fragen zu kommen.</p>
<p>Und das ist fÃ¼r mich ein gamechanger, und super sinnvoller Einsatz von KI.</p>
<p>Hier mal ein Auszug aus einem <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/Python-Lernen-mit-Fragen.pdf">Chat mit Chat-GPT</a>. Das ist sicher nicht perfekt, aber ein starker Anfang. Chapeau, Chat-GPT!</p>

    </section>
    
      <footer>
        <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">
        Was ist blooms taxonomie? Die &#39;wichtigsten&#39; oberen Ebenen
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2024-09-06">Friday, September 6, 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/bloom.jpeg" alt="Blooms Taxonomie"></p>
<p>In <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">meinem ersten Blog-Post habe ich mich mit Blooms Taxonomie beschÃ¤ftigt</a>. Im <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">zweiten ging es um die ersten drei Ebenen seines Lernmodells</a>. Hier geht es jetzt um die mir am wichtigsten ebenen vier und fÃ¼nf. Und der VollstÃ¤ndigkeit halber auch auch um die sechste.</p>
<p>Und los gehts!</p>
<h2>Die Ebenen von <a href="https://de.wikipedia.org/wiki/Blooms_Taxonomie">Blooms Taxonomie</a>:</h2>
<h3>4. Analyse</h3>
<p>Auf dieser Ebene geht es darum, Wissen und Informationen in seine Bestandteile zu zerlegen um Beziehungen und Strukturen zu erkennen und Verstehen. Hier geht es erstmals um kritisches Denken und das erkennen von Mustern.</p>
<p><em>Fragen</em>: "Welche Elemente bilden das Gesamtkonzept?" oder "Wie hÃ¤ngen die Teile zusammen?" und "Was sind die zugrunde liegenden Annahmen?" Diese Fragen helfen uns, tiefer in das Thema einzutauchen und es aus verschiedenen Perspektiven zu betrachten.</p>
<p><em>TÃ¤tigkeit</em>: Untersuchen, Zerlegen, Beziehungen erkennen, Vergleichen. Hier geht es darum, das erlernte Wissen zu analysieren, zu hinterfragen und mit schon gelerntem aus anderen Themen zu vergleichen und zu kontrastieren.</p>
<p>Die FÃ¤higkeit, komplexe Informationen zu durchdringen und logische Verbindungen herzustellen.</p>
<p><em>Lernziel</em>: Ich kann komplexe Informationen durchdringen, zerlegen und logische Beziehungen erkennen. Auch zu anderem bisher gelernten. Das Ergebnis dieser Lernstufe ist die FÃ¤higkeit, das Gelernte zu analysieren und zu hinterfragen.</p>
<p>Daher ist diese Ebene und Ihre Fragestellung auch mit der nÃ¤chsten so wichtig, um langfristig zu behalten was man gelernt hat (verknÃ¼pfungen und kontrastierung zu anderem was man schon kann). AuÃŸerdem: Wenn man sich von Anfang an mit diesen Fragen beschÃ¤ftigt, kriegt man in der gleichen Lernzeit Ebene 1-3 quasi umsonst.</p>
<p><em>Beispiel</em>: Ein Softwareentwickler kÃ¶nnte beispielsweise den Code eines Programms analysieren, um Fehler zu finden oder um zu verstehen, wie verschiedene Teile des Codes zusammenarbeiten. In einem Konflikt kÃ¶nnte ich die Argumente analysieren, um Bestandteile, Beziehungen zwischen den Argumenten und die dahinter stehenden Annahmen, deren Logik, und die historische Beziehung der konflikteten Parteien zu bewerten.</p>
<h3>5. Evaluieren</h3>
<p>Jetzt, wo wir das Wissen analysiert und zerlegt haben, geht es darum, dieses Wissen zu bewerten, zu kritisieren und zu priorisieren. Es geht darum, fundierte Urteile zu fÃ¤llen und Kritik zu Ã¼ben.</p>
<p><em>Fragen</em>: "Ist diese These Valide?", "Wie effektiv ist diese Methode?", "Welche vor und Nachteile hat dieser Ansatz?", "Welcher andere Ansatz ist aus welchen GrÃ¼nden besser?" oder "Welche Methode sollte ich priorisieren?" Diese Fragen helfen uns, das Wissen zu bewerten und Entscheidungen zu treffen.</p>
<p><em>Lernziel</em>: Das Ergebnis dieser Lernstufe ist die FÃ¤higkeit, das Gelernte kritisch anhand der fÃ¼r meine Situation relevanten Kriterien zu bewerten und Entscheidungen zu treffen. Es geht darum, das Wissen zu nutzen, um fundierte Entscheidungen zu treffen und PrioritÃ¤ten zu setzen.</p>
<p><em>TÃ¤tigkeit</em>: FÃ¼hren von Debatten, Entscheidung zwischen AnsÃ¤tzen, Bewerten von Projekten und Theorien. Hier geht es darum, das erlernte Wissen zu bewerten und zu priorisieren.</p>
<p><em>Beispiel</em>: In einem Projekt oder bei der Softwareentwicklung verschiedene Strategien oder UmsetzungsmÃ¶glichkeiten bewerten und entscheiden, welche am besten umgesetzt werden sollte. Oder auch kleiner: Bewertung der GlaubwÃ¼rdigkeit einer Quelle. Kritisches hinterfragen von MaÃŸnahmen und (politischen) Entscheidungen.</p>
<h3>6. Erzeugen</h3>
<p>Einleitung: Die hÃ¶chste Ebene ist das Erschaffen, bei dem ein neues oder originelles Werk entwickelt wird. Es geht darum, Wissen und Ideen auf innovative Weise zu kombinieren und neue Konzepte zu entwickeln.</p>
<p><em>Fragen</em>: "Was wÃ¤re, wenn...?" oder "Wie kÃ¶nnte ich...?". "KÃ¶nnte ich [Problem X] vielleicht auch ganz anders angehen?", "Kann ich diese Konzepte vielleicht auch so kombinieren?"</p>
<p><em>Lernziel</em>: Kreativit und Innovativ eigene Ideen in Produkte umsetzen.</p>
<p><em>TÃ¤tigkeit</em>: Entwickeln von Projekten oder Modellen. Schreiben von Texten. Entwerfen von Experimenten oder Prototypen.</p>
<p><em>Beispiel</em>: Als Softwareentwickler entwickle ich eine Software. Ich schreibe ein Gedicht. Ich fÃ¼hre eine neue Software ein um ein altes Problem neu besser zu lÃ¶sen.</p>
<h2>Warum ist mir das so wichtig?</h2>
<p>Seit den 1960er Jahren wird Blooms Taxonomie dazu verwendet, um einzuschÃ¤tzen, wie gut ich und andere ein Thema verstanden haben. Und erst jetzt kriege ich raus, dass es a) existiert, und ich es b) dazu verwenden kann mein eigenes Lernen besser zu verstehen und zu vertiefen? Boah ey, wieso hat mir das in der Schule niemand erklÃ¤rt? Oder wenn, wieso dann nicht auf eine Weise die ich verstanden habe? Ich fÃ¼hle mich im Moment so, als wurde mir hier Ã¼ber Jahre etwas wichtiges vorenthalten.</p>
<p>So, das wars. Jetzt wisst Ihr so viel Ã¼ber das Modell und seine Ebenen wie ich auch. <a href="2024/10/waehrend-dem-lernen-lernen-lernen-ki-nutzen/">NÃ¤chstes mal soll es dann darum gehen wie man mit hilfe von KI sich selbst auf die Ebene des Lernens Katapultieren kann auf der man gerade sein will.</a></p>
<p>Bis dahin, bleibt neugierig und probiert es doch mal aus in diesen Kategorien Ã¼ber euer eigenes Lernen nachzudenken.</p>

    </section>
    
      <footer>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">
        Was ist blooms taxonomie? Die ersten Ebenen
        </a>
      </h2>
      <p class="meta">
        written by Martin HÃ¤cker on <time datetime="2024-09-06">Friday, September 6, 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/bloom.jpeg" alt="Blooms Taxonomie"></p>
<p>In <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie/">meinem letzten Blog-Post habe ich mich mit Blooms Taxonomie beschÃ¤ftigt</a>. Mir hat dieses Modell viele GedankenanstÃ¶ÃŸe darÃ¼ber gegeben, wie ich lerne. Ich habe die sechs Ebenen von Blooms Taxonomie vorgestellt und ihre Anwendung sehr knapp diskutiert. Heute mÃ¶chte ich diese Ebenen vertiefen und anhand von Beispielen auf die Unterschiede zwischen den Ebenen eingehen sowie die jeweiligen Lernziele beleuchten. Mein Ziel ist es, mir und anderen, die Anwendung von Blooms Taxonomie in beim Lernen zu veranschaulichen. Los gehts!</p>
<h2>Die Ebenen von <a href="https://de.wikipedia.org/wiki/Blooms_Taxonomie">Blooms Taxonomie</a>:</h2>
<h3>1. Wissen</h3>
<p>Die Grundlage fÃ¼r alles. Hier geht es darum, sich an Fakten und Informationen zu erinnern. (Wer hÃ¤tte das gedacht? ;)</p>
<p><em>Fragen</em>: "Was sind die Fakten?" oder "Was weiÃŸ ich Ã¼ber dieses Thema?"</p>
<p><em>TÃ¤tigkeit</em>: Sich was merken. Hier helfen z.B. GedÃ¤chtnis-Tricks wie ein <a href="https://de.wikipedia.org/wiki/GedÃ¤chtnispalast">GedÃ¤chtnispalast</a>, aber meine Empfehlung ist ein durchsuchbares Notizbuch als externalisiertes GedÃ¤chtnis zu fÃ¼hren. Warum? Weil das wunderbar fÃ¼r alle weiterne Ebenen verwendbar ist. :) Ich verwende derzeit <a href="https://www.agenda.com">Agenda</a>, aber wenn ich jetzt neu anfangen wÃ¼rde, <a href="https://logseq.com">wÃ¼rde ich Logseq verwenden</a>.</p>
<p><em>Lernziel</em>: Ich kann dieses Wissen wiedergeben. Wenn Du aber nur auf dieser Ebene lernst, dann geht es Dir wie mir nach den Klausuren - eine Woche SpÃ¤ter hatte ich das meiste erfolgreich wieder vergessen. :)</p>
<p><em>Beispiel</em>: Welche Module und Funktionen gibt es grob in der Standardbibliothek meiner Programmiersprache? Oder: Welche Themen muss ich fÃ¼r die Klausur kennen? Welche Punkte hat jedes Unterthema?</p>
<h3>2. VerstÃ¤ndnis</h3>
<p>Aufbauend auf Wissen, geht es jetzt darum Informationen zu interpretieren, zu erklÃ¤ren und erste ZusammenhÃ¤nge herzustellen.</p>
<p>Es reicht nicht mehr aus, nur Fakten zu kennen, sondern es ist wichtig, ihre Bedeutung zu verstehen und sie in einen Kontext einzuordnen.</p>
<p><em>Fragen</em>: "Kann ich das Gelernte in eigenen Worten erklÃ¤ren?" oder "Kann ich ein Beispiel fÃ¼r das Gelernte geben?" Damit kann ich das Gelernte verstehen und in einen Kontext einordnen.</p>
<p><em>TÃ¤tigkeit</em>: Interpretieren, ErklÃ¤ren, In eigenen Worten wiedergeben, Zusammenfassen, mit schon gelerntem Vergleichen, Beispiele geben.</p>
<p><em>Lernziel</em>: Ich kann das gelernte jemand anderem erklÃ¤ren. (Also unter andere dass, was ich hier gerade mache). Damit kriege ich selbst ein viel tieferes VerstÃ¤ndnis der Materie, und vergesse es auch viel weniger. Hier greift die alte Volksweisheit: Wer lehrt, lernt zweimal.</p>
<p><em>Beispiel</em>: vor einer Klausur einen guten und vollstÃ¤ndigen Spickzettel zu schreiben ist super. Ãœberraschung: den braucht man in der Klausur dann Ã¼blicherweise nicht. :) Warum hilft das? Weil man hier strukturiert die (Lern)-Notizen zusammenfasst. Gerne als Mind-Map oder als Info-Graphik. Optimal: In einer Lern-Gruppe oder einem Kollegen etwas erklÃ¤ren.</p>
<h3>3. Anwendung</h3>
<p>Mit dem VerstÃ¤ndnis an der Hand, geht es jetzt darum Wissen in die Praxis zu Ã¼bersetzen. Gefordert sind (noch) keine groÃŸen Ãœbertragungsleistungen, sondern eine direkte Anwendung des Gelernten in bekannten Kontexten.</p>
<p><em>Fragen</em>: "Wie kann ich das Gelernte in einer bestimmten Situation oder bei einer bestimmten Aufgabe anwenden?" oder "Welche Probleme kann ich mit diesem wissen lÃ¶sen?" Es geht darum das Gelernt auf bekannte Probleme anzuwenden.</p>
<p><em>TÃ¤tigkeit</em>: Anwenden, AusfÃ¼hren, DurchfÃ¼hren. Hilft alles nichts, man muss es mal praktisch in bekannten und neuen Situationen anwenden.</p>
<p><em>Lernziel</em>: Ich kann das Gelernte in Ã¤hnlichen Kontexten anwenden. Das Ergebnis dieser Lernstufe ist die FÃ¤higkeit, einfache ProblemlÃ¶sungen durchzufÃ¼hren. Es geht darum, das Gelernte in die Praxis umzusetzen und zu zeigen, dass man das Wissen nicht nur besitzt, sondern auch anwenden kann.</p>
<p><em>Beispiel</em>: Ein Programmierer kÃ¶nnte <a href="https://adventofcode.com">eine Aufgabe aus Advent Of Code</a> lÃ¶sen um das dahinter liegende Konzept zu verstehen. Ein Administrator nach einer Schulung die Sicherheitseinstellungen eines Netzwerk PrÃ¼fen und verbessern. Ein Agiler Team-Teilnehmer ein neu gelerntes Projekt-Management Werkzeug in einem agilen Experiment ausprobieren.</p>
<h2>Fazit</h2>
<p>Beim Schreiben ist mir aufgefallen wie schwer es ist diese Ebenen kurz und Knapp vorzustellen. Es gibt ja noch drei weitere Ebenen, aber ich wollte eure geschÃ¤tzte Aufmerksamkeit nicht noch weiter QuÃ¤len. :)</p>
<p>Daher habe ich hier abgetrennt. Diese ersten Ebenen sind zwar essenziell um zu verstehen wie das alles gemeint ist. Aber den eigentlichen Schatz heben wir erst auf der 4. und 5. Ebene: Analyse und Evaluation. <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-4-6/">Und darum geht es (sicher fÃ¼r den geehrten Leser vÃ¶llig Ã¼berraschend) in meinem nÃ¤chsten Blog Post</a>. :)</p>

    </section>
    
      <footer>
        <a href="2024/9/waehrend-dem-lernen-lernen-lernen-blooms-taxonomie-ebene-1-3/">weiterlesenâ€¦</a>
      </footer>
    
  </article>

  
  
  
    
  <div class="pagination">
    
      <span class="disabled">&laquo; Previous</span>
    
    | 1 |
    
      <a href="page/2/">Next &raquo;</a>
    
  </div>

  

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2025 <a href="../work/">Martin HÃ¤cker</a></span>
  </li>
  
    
    <li class="nav-item imprint">
      <a class="nav-link" href="../meta/#imprint">
        Imprint
      </a></li>
  
    
    <li class="nav-item privacy-policy">
      <a class="nav-link" href="../meta/#privacy-policy">
        Privacy Policy
      </a></li>
  
    
    <li class="nav-item colophon">
      <a class="nav-link" href="../meta/#colophon">
        Colophon
      </a></li>
  
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="../../blog/feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    <a class="nav-link" 
      rel="license" 
      target="_blank" 
      href="https://creativecommons.org/licenses/by-sa/4.0/deed"
    >
      <img 
        src="/static/cc-by-sa-88x31.png"
        alt="Creative Commons Attribution - Share Alike 4.0 International Lizense"
      >
    </a>
  </li>
</ul>
    </footer>
  </body>
</html>
