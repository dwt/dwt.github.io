
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="../static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/pygments.css">
    <title>🏠</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin Häckers Blog Artikel" href="../blog/feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="./" class="navbar-brand active">🏠<span class="sr-only">(ausgewählt)</span></a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="work/" class="nav-link">Professional software development</a></li>
    
      <li class="nav-item "><a href="projects/" class="nav-link">Projects</a></li>
    
      <li class="nav-item "><a href="publications/" class="nav-link">Publications and talks</a></li>
    
      <li class="nav-item "><a href="blog/" class="nav-link">Blog</a></li>
    
      <li class="nav-item "><a href="categories/" class="nav-link">Categories</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="../">🇩🇪</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="./">🇬🇧</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

<a class="breadcrumb-item active" href="./">🏠</a>

</nav>
    </header>
    <article class="page  homepage container-fluid">
      
  <h1>Welcome!</h1>
<p>I'm <a href="../work">Martin Häcker</a>, a software developer with more than 20 years of experience. I can assist with <a href="../work">all aspects of professional software development</a>.</p>
<p>My blog is about <a href="../categories/code/">Software</a>, <a href="../categories/liquid/">Liquid Democracy</a>, <a href="../categories/go/">Go / Baduk / Weiqi</a>, <a href="../categories/cucina/">Kochen</a>, <a href="http://gropies.de/">choir singing</a>, <a href="https://en.wikipedia.org/wiki/Bouldering">bouldering</a>, <a href="https://en.wikipedia.org/wiki/Cue_sports">billiard</a>, <a href="https://en.wikipedia.org/wiki/Paragliding">paragliding</a>, <a href="https://en.wikipedia.org/wiki/Category:Kites">kiting</a>, <a href="https://en.wikipedia.org/wiki/Juggling">juggling</a> and <a href="../categories/">other things that interest me</a>. Look around, <a href="../projects/">use my code</a> and <a href="../blog/feed.xml">subscribe to my feed</a> to enjoy reading the blog in the comfort of your feed reader.</p>
<p>While my website is available in English and German, most of my blog will be single language. Mostly in German, but occasionally in English.</p>
<h1>Newest Entries:</h1>

  
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/5/die-freuden-einer-gut-eingerichteten-shell-fzf/">
        Die Freuden einer gut eingerichteten Shell: fzf
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-05-07">Wednesday, May 7, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="../blog/2025/5/die-freuden-einer-gut-eingerichteten-shell-fzf/fzf.png" alt="fzf"></p>
<p>Nachdem es bisher in <a href="../categories/code/">der Serie</a> um die <a href="../blog/2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">grundlegende Einrichtung der Shell</a>, <a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/">einen guten Prompt</a> und <a href="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/">funktionierende autoomatische Vervollständigung</a> ging, geht es jetzt eine Weile um Werkzeuge um mit der Shell effizient zu navigieren und Dateien und Inhalte zu finden.</p>
<h2>Einleitung</h2>
<p>Hier geht es mir darum das die Arbeit auf der Shell (auf dem eigenen Rechner vor allem) nur dann schnell und Effizient ist, wenn man schnel und einfach in die Ordner kommt in denen man arbeiten möchte, und die Dateien findet in denen etwas interessantes steht das man entweder lesen oder verändern möchte.</p>
<p>Und natürlich ist das Skillset auch auf beliebige Server transferierbar, weil man alle diese Werkzeuge (oder deren etwas primitivere Variante, dazu später mehr) auch auf einem Server, oder in einem Docker-Container, gerne auch auf einem Kubernetes-Cluster in Produktion einsetzen kann, wo man sonst halt nicht so viele Werkzeuge hat, und schon gar nicht seine IDE anschließen kann um zu versuchen dort Herr der Lage zu werden.</p>
<p>Dazu möchte ich euch die Tools <a href="https://github.com/ajeetdsouza/zoxide">zoxide</a>, grep/<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>, <a href="https://github.com/junegunn/fzf">fzf</a>, less/cat/<a href="https://github.com/sharkdp/bat">bat</a> und <a href="https://direnv.net">direnv</a> vorstellen.</p>
<p>Diese Tools erleichtern viele täglich oft wiederholte Arbeitsabläufe dramatisch, und sie ermöglichen viele Use-Cases, die viele grafischen IDEs und Text-Editoren gar nicht unterstützen. Los geht es mit dem flauschigsten der Tools, fzf.</p>
<h2>Zackig die richtige Datei finden: fzf</h2>
<p><a href="https://github.com/junegunn/fzf">fzf</a> frei Eingezangendeutscht "der flauschige Kommandozeilen Finder", ist ein werkzeug um Dateien (aber auch beliebige andere Dinge) anhand von teilen des Namens oder Mustern wie jeder erste Buchstabe der Wörter ihres Namens zu finden. Dazu bietet dieses Werkzeug eine Oberfläche die interaktiv die Liste der Auswahlmöglichkeiten filtert während man tippt. Die meisten IDEs bieten so eine Funktion irgendwo mehr oder weniger gut versteckt an, und dieses Werkzeug portiert diese Funktionalität als generisches Werkzeug in die Shell.</p>
<p>Als beispiel: Ich möchte einen bestimmten UnitTest ausführen:</p>
<div class="hll"><pre><span></span>$<span class="w"> </span>bin/run_tests_in_docker.sh<span class="w"> </span><span class="k">$(</span>fzf<span class="k">)</span>
</pre></div>
<p>Mit diesem Kommando, wird zuerst fzf aufgerufen (wegen <code>$(fzf)</code>) was dann eine oberfläche präsentiert, mit der man interktiv die richtige oder die richtigen Dateien auswählen kann.</p>
<div class="hll"><pre><span></span><span class="c"># ich verwende die fish shell, daher brauch ich das $ nicht</span>
❯ bin/run_tests_in_docker.sh <span class="o">(</span>fzf<span class="o">)</span>
  src/models/dokumente/tests/document_distribution_test.py
  src/controller/process_distribution/tests/models_test.py
  src/models/dokumente/tests/dokumente_test.py
  src/integration/d3/api/test/models_test.py
▌ src/models/tests/kontaktdaten_test.py
  5/448 ────────────────────────────────
<span class="o">&gt;</span> models <span class="err">&#39;</span><span class="k">test</span>.py
</pre></div>
<p>In dem Interface kann man auch mit den Pfeiltasten navigieren, oder einen Eintrag anklicken. Der von mir eingegebene Suchstring "models 'test.py" bedeutet, dass 'models' irgendwo in dem Treffer diese Buchstaben in dieser Reihenfolge vorkommen müssen, während "'test.py" erzwingt das der exakte String 'test.py' vorkommen muss.</p>
<p><a href="https://junegunn.github.io/fzf/shell-integration/">Wenn man die fzf-Integration mit der eigenen Shell aktiviert</a>, kriegt man viele weitere Integrationen in die Shell dazu. Zwei Beispiele:</p>
<ul>
<li><p><code>⌃-T</code> sucht (mit Vorschau!) nach Dateien unterhalb des aktuellen Verzeichnisses. Das ist immer dann Praktisch wenn man für ein Kommando eine Datei aus dem aktuellen Projekt als Argument übergeben muss, und spart das tippen von <code>$(fzf)</code>. Klar, mit Auto-Vervollständigung kommt man auch ans Ziel, aber das ist <em>soo</em> viel schneller. Insbesondere wenn man nicht genau im Kopf hat wo die Datei liegt, aber noch weiß was in Ihrem Namen oder Pfad vorkommen muss. Das verwende ich die ganze Zeit.</p>
</li>
<li><p><code>⌃-R</code> sucht mit <code>fzf</code> in der Shell-Historie. Das funktioniert viel besser als die Standard-Suche, die nur nach direkt zusammenhängenden Buchstaben suchen kann. Ein Beispiel: Das Wenn ich das Kommando <code>helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml | yq</code> aus meiner historie suchen möchte, müsste ich ohne <code>fzf</code> den exakten Text schreiben der in dem Kommando vorkommt.</p>
</li>
</ul>
<div class="hll"><pre><span></span>~
Search History&gt; helmtemplateexten
  76/32637 <span class="o">(</span>0<span class="o">)</span>
  02-17 18:07:03 │ helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml
  02-17 18:06:10 │ helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml <span class="o">|</span> yq
  02-17 17:59:53 │ helm template extensions ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
  02-17 20:22:18 │ helm template  extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml
  02-17 18:15:27 │ helm template --debug extensions ./k8s/extensions/ --values ./k8s/extensions/values.dev.yaml
  02-17 17:59:42 │ helm template --dry-run --debug extensions ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
▌ 02-17 17:59:29 │ helm template --dry-run --debug  ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
  02-17 17:59:36 │ helm template --dry-run --debug foo ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml
╭──────────────────────────────────────────────────────────────────────────────────────────────╮
│ helm template --dry-run --debug ./k8s/extensions/ --values ./k8s/extensions/values-dev.yaml  │
╰──────────────────────────────────────────────────────────────────────────────────────────────╯
</pre></div>
<p>Wenn ich oft, wenn ich ein neues Terminal öffne in die gleichen Projekte navigiere, dann geht das prima über die Shell-History:</p>
<div class="hll"><pre><span></span>❯ <span class="c"># ctrl-r für history suche</span>
Search History&gt; cdmkkapi
  352/32638 <span class="o">(</span>0<span class="o">)</span> ──────────────────────────
  08-12 11:56:19 │ <span class="k">cd</span> mkk/api
  08-24 19:05:13 │ <span class="k">cd</span> ../mkk/api
▌ 05-26 08:39:19 │ <span class="k">cd</span> Code/Projekte/mkk/api
  07-29 17:02:48 │ <span class="k">cd</span> Code/Projekte/mkk/api_infra/
  02-15 08:37:01 │ <span class="k">cd</span> Code/Projekte/mkk/api_infra/monitoring/
╭──────────────────────────╮
│ <span class="k">cd</span> Code/Projekte/mkk/api │
╰──────────────────────────╯
</pre></div>
<p>Mit <a href="https://github.com/ajeetdsouza/zoxide">Zoxide</a> geht das noch besser, aber dazu später mehr.</p>
<p>So habe ich meine fzf Integration konfiguriert:</p>
<div class="hll"><pre><span></span><span class="c"># configure key-bindings for fzf-fish</span>
<span class="c"># ctrl-f directory search</span>
<span class="c"># ctrl-r history search</span>
<span class="c"># ctlr-v variables search</span>
<span class="c"># ctrl-l git log search</span>
<span class="c"># ctrl-s git status search</span>
<span class="c"># ctrl-p processes pid search</span>
fzf_configure_bindings --git_log<span class="o">=</span><span class="se">\f</span> --directory<span class="o">=</span><span class="se">\c</span>F --git_status<span class="o">=</span><span class="se">\c</span>S --processes<span class="o">=</span><span class="se">\c</span>P
</pre></div>
<p>Das geniale an fzf ist, dass es sich so wunderbar in andere Tools integrieren lässt. Hat man es installiert wird es z.B. von <a href="https://github.com/ahmetb/kubectx">KubeCTX</a> verwendet um in <code>kubectx</code> die liste der verbundenen Kubernetes Cluster zu filtern. Oder von <code>kubens</code> um die Liste der Namespaces. Tatsächlich verwenden viele Werkzeuge intern <code>fzf</code> wenn es instaliert ist. Für mich immer wieder eine schöne Überrachung, wenn ein weiteres Werkzeug das ich gerne einsetze <code>fzf</code> verwendet.</p>

    </section>
    
      <footer>
        <a href="../blog/2025/5/die-freuden-einer-gut-eingerichteten-shell-fzf/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/">
        Die Freuden einer gut eingerichteten Shell: Autocomplete
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-04-14">Monday, April 14, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <h2>Was ist schlechte Vervollständigung?</h2>
<p>Um zu verstehen was ich mit guter Auto-Completion für Shells meine, brauchen wir erst einmal eine Baseline wie eine schlechte Completion aussieht. Das lässt sich sehr gut mit Docker demonstrieren: </p>
<div class="hll"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>--rm<span class="w"> </span>-it<span class="w"> </span>--hostname<span class="w"> </span>shell-completion-demo<span class="w"> </span>debian
</pre></div>
<p>Erstes Experiment: <code>ls⇥⇥</code> (kein Leerzeichen vor den Tabs!)</p>
<p><img src="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-commands-unconfigured.png" alt="Automatische Vervollständigung von Kommandos - unkonfiguriert"></p>
<p>Zeigt alle Kommandos die mit <code>ls</code> anfangen
Zweites Experiment: <code>ls ⇥⇥</code>
Das zeigt bei mir:</p>
<p><img src="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-files-unconfigured.png" alt="Automatische Vervollständigung von Dateien - unkonfiguriert"></p>
<p>Schon mal gut, denn hier werden die Dateien im aktuellen Ordner vervollständigt.</p>
<p>Nächste Schwierigkeitsstufe - kurze und lange Optionen: <code>ls -⇥⇥</code> (Minus vor dem Tab)
Das zeigt hier nichts, genauso für lange Optionen <code>ls --⇥⇥</code> (zwei mal Minus vor dem Tab)</p>
<p>Keine Ausgabe. <code>ls</code> ist eigentlich so ungefähr das einfachste Programm das jeder Shell beiliegt. Wenn automatische Vervollständigung also irgend etwas kann, dann sollte <code>ls</code> gut funktionieren.</p>
<h2>Was ist gute Vervollständigung?</h2>
<p>Dagegen mal ein Beispiel von meinem System:</p>
<p><code>ls⇥</code> zeigt die Kommandos die mit ls anfangen, mit einer Kurzbeschreibung was diese Kommandos tun.</p>
<p><img src="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-commands-configured.png" alt="Vervollständigung von Kommandos mit der Fish-Shell"></p>
<p>Schon mit einem Tab sehe ich die Dateien, und zusätzlich sehe ich als Vorschlag den letzten Befehl den ich mit <code>ls</code> abgesetzt habe und kann diesen mit <code>⌃→</code> im ganzen, oder mit  <code>→</code> wortweise akzeptieren kann.</p>
<p><img src="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-files-configured.png" alt="Automatische Vervollständigung von Dateien mit der Fish Shell"></p>
<p>Ein ls -⇥<code>ergibt sofort eine Optionsliste - kurz und lang - mit einer Kurzbeschreibung was dieses Schalter tun. Ein zweites Minus und Tab</code>ls --⇥` zeigt nur noch die langen Optionen an:</p>
<p><img src="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-options-configured.png" alt="Vervollständigung von Optionen mit der Fish-Shell">
<img src="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/autocomplete-long-options-configured.png" alt="Vervollständigung von langen Optionen mit der Fish-Shell"></p>
<p>Natürlich kann ich mit den Pfeiltasten oder mit Tab eine der Optionen auswählen - natürlich mit ordentlichem Highlighting.
So macht arbeiten auf der Shell Spaß!</p>
<p>Falls Ihr verwirrt seid das mein ls andere Optionen anbietet als eures, dann liegt das daran <a href="https://github.com/ogham/exa">das ich ls durch exa ersetzt habe</a>.</p>
<h2>Wie könnt Ihr das bei euch nutzen?</h2>
<p>Ich nutze die <a href="https://fishshell.com">Fish-Shell</a>, da diese von Haus aus eine sehr gute Autocompletion anbietet. Das ist aber nicht für jede, denn die Syntax der Fish Shell ist etwas anders als bei Bash/ZSH - eben nicht posix kompatibel. Ich mag das Weil es logischer und Kürzer ist, aber ich komme auch nicht durcheinander mit den verschiedenen Shell-Syntaxen da ich sie schon so lange verwende.</p>
<p>Fast alle Shell Konfigrurations-Frameworks wie <a href="https://ohmyz.sh">oh-my-zsh</a> oder <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> bieten zumindest etwas an das diesem Nahe kommen. Alle automatische Konfiguration stößt aber irgendwann an Ihre Grenzen wenn es um die Kommandos geht, die wir täglich benutzen. <code>docker</code> vervollständigt dann nicht compose und oder kennt die Unterkommandos davon nicht oder nur unvollständig, kubectl und helm sind notorische Kandidaten für die man sich selber kümmern muss.</p>
<p>Jetzt könnte man natürlich versuchen automatisch aus der Hilfsausgabe dieser Kommandos etwas zu generieren (das macht z.B. die Fish shell von sich aus) oder man schreibt selber etwas (argh).</p>
<p>Oder man wendet sich vertrauensvoll an das tool <a href="https://github.com/carapace-sh/carapace">carapace</a>, mit dem man die Completion für Programme komfortabel für alle Shells nachrüsten kann. Als Beispiel um die die Autocompletions für kubectl nachzurüsten, einfach <code>source &lt;(carapace kubectl zsh)</code> oder <code>carapace kubectl fish | source</code> (je nach shell) eingeben und ausprobieren ob es gefällt, und wenn ja, diese Zeile in die User-Konfiguration deiner shell eintragen und viel glücklicher sein.</p>
<p>Obacht: Man kann mit so einem Snippet</p>
<div class="hll"><pre><span></span><span class="c1"># ~/.zshrc </span>
<span class="nb">export</span><span class="w"> </span><span class="nv">CARAPACE_BRIDGES</span><span class="o">=</span><span class="s1">&#39;zsh,fish,bash,inshellisense&#39;</span><span class="w"> </span><span class="c1"># optional</span>
zstyle<span class="w"> </span><span class="s1">&#39;:completion:*&#39;</span><span class="w"> </span>format<span class="w"> </span><span class="s1">$&#39;\e[2;37mCompleting %d\e[m&#39;</span>
<span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>carapace<span class="w"> </span>_carapace<span class="o">)</span>
</pre></div>
<p>in seiner Shell-Konfiguration alle completer des Carapace Projekts aktivieren. Das hat mir allerdings nicht gefallen,, da ich manche der eingebauten Completer der Fish-Shell noch etwas besser finde als das was Carapace bereit stellt. Aber um Lücken zu ergänzen? Perfekt!</p>
<p>Meine Shell-Completion Konfiguration (fish!) sieht daher so aus:</p>
<div class="hll"><pre><span></span><span class="c"># enable shell completions</span>
<span class="k">set</span> --global --export CARAPACE_BRIDGES <span class="s1">&#39;zsh,fish,bash,inshellisense&#39;</span>
<span class="c"># I didn&#39;t have much luck enabling all carapace completions, but I do like some of them - especially if there is no built in fish completion for them</span>
<span class="c"># carapace _carapace | source</span>
carapace fd <span class="o">|</span> <span class="nb">source</span>
carapace bat <span class="o">|</span> <span class="nb">source</span>
carapace brew <span class="o">|</span> <span class="nb">source</span>
carapace rg <span class="o">|</span> <span class="nb">source</span>
carapace docker <span class="o">|</span> <span class="nb">source</span>
uv generate-shell-completion <span class="nb">fish</span> <span class="o">|</span> <span class="nb">source</span>
yq completion <span class="nb">fish</span> <span class="o">|</span> <span class="nb">source</span>
</pre></div>

    </section>
    
      <footer>
        <a href="../blog/2025/4/die-freuden-einer-gut-eingerichteten-shell-autocomplete/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/">
        Die Freuden einer gut eingerichteten Shell: Der Prompt
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-02-27">Thursday, February 27, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/terminal.jpg" alt="Terminal"></p>
<p>Es fängt natürlich mit der Frage an: welche Shell?</p>
<p>Das ist sehr einfach zu beantworten. Auf MacOS ist die <a href="https://www.zsh.org">zsh</a> die Standard-Shell - und daher sollte man die auch benutzen. Artikel Fertig, vielen Dank fürs Lesen! 😅</p>
<p>Windows hat die <a href="https://de.wikipedia.org/wiki/PowerShell">PowerShell</a> - wer damit Arbeiten (muss) sollte sie lernen!</p>
<p>Die nackte Shell ist ziemlich schlecht konfiguriert, da die Möglichkeiten der Shell gar nicht ausgenutzt werden. Auf Linux-Distributionen ist es Standard, dass die Shell von der Distribution eingerichtet wird, daher kann man damit meistens schon gut arbeiten.</p>
<p>Aber für MacOS (und Windows) gibt es viel zu tun.</p>
<p>So sieht die zsh unkonfiguriert aus:</p>
<div class="hll"><pre><span></span>dwt@NB1321<span class="w"> </span>~<span class="w"> </span>%<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>Library/Favorites
dwt@NB1321<span class="w"> </span>Favorites<span class="w"> </span>%
</pre></div>
<p>Das ist schon gar nicht schlecht, denn man sieht einiges:</p>
<ul>
<li><code>dwt</code>: Welcher Nutzer man gerade ist. Wichtig, wenn man viel mit <code>sudo</code> arbeitet, damit man nicht versehentlich Kommandos als <code>root</code> mit zu vielen Rechten ausführt.</li>
<li><code>NB1321</code>: Auf welchem Rechner man gerade eingeloggt ist. Wichtig wenn man auf vielen Rechnern arbeitet und nicht</li>
<li>Den aktuellen Ordner in dem man ist (<code>Favorites</code>). Wichtig damit man z.B. nicht versehentlich die falschen Dateien löscht.</li>
<li>Der Prompt <code>%</code> trennt die Meta-Informationen von dem was man selbst eingibt.</li>
</ul>
<p>Da geht aber noch wesentlich mehr. Bei mir z.B. sieht der Prompt so aus:</p>
<div class="hll"><pre><span></span>~/C/P/m/api<span class="w"> </span>❄️<span class="w"> </span>🧪<span class="w"> </span>nix-shell-env<span class="w">   </span>🐍<span class="w"> </span>venv<span class="w"> </span>⛵️<span class="w"> </span>mkk-itsc-dev<span class="w"> </span><span class="o">(</span>api<span class="o">)</span><span class="w"> </span>🌱<span class="w"> </span>main<span class="w"> </span><span class="nv">$!</span><span class="w">  </span>4s
❯
</pre></div>
<p>Da ist enthalten:</p>
<ul>
<li><code>~/C/P/m/api</code> - nicht nur der aktuelle Ordner, sondern auch jeweils der Anfangsbuchstabe der darüber liegenden Ordner. Das liefert platzsparend viel mehr Kontext, wo man gerade ist. Super wenn man in vielen Projekten gleichnamige Ordner wie z.B. <code>etc</code>, <code>src</code> oder <code>dist</code> hat.</li>
<li><code>❄️ 🧪 nix-shell-env</code> Zeigt an, dass gerade eine 'dreckige' <a href="https://nixos.wiki/wiki/Development_environment_with_nix-shell">Nix-Shell</a> aktiv ist. Das verwende ich um Projek-spezifische Abhängigkeiten (Shell-Tools, bestimmte Vesionen von Python etc.) zu installieren die ich deklarativ im Projekt tracke. Gut vergleichbar mit Python-Virtual-Envs - aber eben für alles, nicht nur Python-Pakete. Dreckig ('impure') ist Sie, da nicht <em>nur</em> die Shell-Tools aus der Nix-Shell sichtbar sind, sondern auch alles andere was ich im Betriebsystem installiert habe.</li>
<li><code>🐍 venv</code> - zeigt an, dass gerade ein Python-Virtual-Env aktiv ist. Da ich hauptsächlich mit Pyton entwickle ist das natürlich entscheidend weil es bedeutet das ich die Projekt-Werkzeuge direkt verwenden kann, da sie im <code>$PATH</code> und <code>$PYTHONPATH</code> sind.</li>
<li><code>⛵️ mkk-itsc-dev (api)</code> zeigt an, dass ich mit dem <code>mkk-itsc-dev</code> Kubernetes Cluster verbunden bin, und den Namespace <code>api</code> aktiviert habe. Das ist mir sehr wichtig, damit ich nicht versehentlich mit <code>kubectl</code> Befehlen versehentlich den Produktiv-Cluster zerstöre. (Rate wieso mir das so wichtig ist…)</li>
<li><code>🌱 main $!</code> zeigt an, dass ich in einem Git-Repository bin, auf dem main branch, das ich dinge ge-'stash't habe (die vergisst man sonst sehr leicht) und das ich Änderungen habe die ich noch nicht commited habe. Hier gibt es <a href="https://starship.rs/config/#git-status">auch noch mehr informationen wenn das Repo den entsprechenden Zustand hat</a>.</li>
<li>Zuletzt sehe ich da das letzte Kommando 4 Sekunden gedauert hat. Das wird nur angezeigt wenn das letzte Programm mehr als 3 Sekunden gedauert hat und ist immer wiede ein hilfreiche Information um bei langlaufenden Prozesen zu verstehen ob es sich lohnt da etwas zu optimieren.</li>
</ul>
<p>Natürlich könnte man hier noch viel mehr anzeigen, je nachdem an was man gerade arbeitet. Ich habe hier eben die Informationen aufgenommen die ich am meisten benötige.</p>
<p>Jetzt kommt der Clou: Früher habe ich das alles von hand Konfiguriert. Das war ein ewiges und mühsammes gefummel um <code>$PS1</code> und konsorten so hinzufummeln das das alles funktioniert hat, und hat nie Spaß gemacht. Der Standard ist derzeit, das man einen Shell-Konfigurations-Framework wie <a href="https://ohmyz.sh">Oh-My-Zsh</a> oder <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> verwendet. Und die sind auch gut. Aber auch langsam, und komplex und kompliziert. Wenn man da mal etwas anders haben will dann gott bewahre wenn das nicht schon vorbereitet ist oder man darf sich nicht nur mit den Komplexitäten von <code>$PS1</code> auseinandersetzen, sondern auch noch damit wie genau dieser Framework das handhabt.</p>
<p>Inzwischen bin ich weiser geworden, und verwende <a href="https://starship.rs">Starship</a>. Damit kann ich meinen Prompt deklarativ in einer <code>.toml</code>-Datei konfigurieren und diesen auch mitnehmen wenn ich mal die Shell wechsle. (Was häufiger vorkommt als mir lieb ist). Und: Starship funktioniert auch mit der PowerShell.</p>
<p><a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/starship.toml">So sieht meine Konfiguration aus</a></p>
<p>Wie richtet man das ein?</p>
<ol>
<li><code>brew install starship</code> (oder mit <a href="https://lix.systems">nix</a>)</li>
<li><code>nano ~/.zshrc</code> und am Ende <code>eval "$(starship init zsh)"</code> einfügen.</li>
<li>Konfigurationsdatei erstellen: <code>nano ~/.config/starship.toml</code> und z.b. <a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/starship.toml">den Inhalt aus der Datei oben einfügen</a>.</li>
<li>Shell neu starten oder neues Terminal öffnen.</li>
</ol>
<p>Danke sagen für die grandiose Verbesserung eures Shell-Lebens bei mir nicht vergessen. 😅</p>

    </section>
    
      <footer>
        <a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell-prompt/">weiterlesen…</a>
      </footer>
    
  </article>

  
  
  <a href="../blog/">Weitere Beiträge…</a>

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2025 <a href="work/">Martin Häcker</a></span>
  </li>
  
    
    <li class="nav-item imprint">
      <a class="nav-link" href="meta/#imprint">
        Imprint
      </a></li>
  
    
    <li class="nav-item privacy-policy">
      <a class="nav-link" href="meta/#privacy-policy">
        Privacy Policy
      </a></li>
  
    
    <li class="nav-item colophon">
      <a class="nav-link" href="meta/#colophon">
        Colophon
      </a></li>
  
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="../blog/feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    <a class="nav-link" 
      rel="license" 
      target="_blank" 
      href="https://creativecommons.org/licenses/by-sa/4.0/deed"
    >
      <img 
        src="/static/cc-by-sa-88x31.png"
        alt="Creative Commons Attribution - Share Alike 4.0 International Lizense"
      >
    </a>
  </li>
</ul>
    </footer>
  </body>
</html>
