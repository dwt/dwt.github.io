
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="../static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/pygments.css">
    <title>🏠</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin Häckers Blog Artikel" href="../blog/feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="./" class="navbar-brand active">🏠<span class="sr-only">(ausgewählt)</span></a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="work/" class="nav-link">Professional software development</a></li>
    
      <li class="nav-item "><a href="projects/" class="nav-link">Projects</a></li>
    
      <li class="nav-item "><a href="publications/" class="nav-link">Publications and talks</a></li>
    
      <li class="nav-item "><a href="blog/" class="nav-link">Blog</a></li>
    
      <li class="nav-item "><a href="categories/" class="nav-link">Categories</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="../">🇩🇪</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="./">🇬🇧</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

<a class="breadcrumb-item active" href="./">🏠</a>

</nav>
    </header>
    <article class="page  homepage container-fluid">
      
  <h1>Welcome!</h1>
<p>I'm <a href="../work">Martin Häcker</a>, a software developer with more than 20 years of experience. I can assist with <a href="../work">all aspects of professional software development</a>.</p>
<p>My blog is about <a href="../categories/code/">Software</a>, <a href="../categories/liquid/">Liquid Democracy</a>, <a href="../categories/go/">Go / Baduk / Weiqi</a>, <a href="../categories/cucina/">Kochen</a>, <a href="http://gropies.de/">choir singing</a>, <a href="https://en.wikipedia.org/wiki/Bouldering">bouldering</a>, <a href="https://en.wikipedia.org/wiki/Cue_sports">billiard</a>, <a href="https://en.wikipedia.org/wiki/Paragliding">paragliding</a>, <a href="https://en.wikipedia.org/wiki/Category:Kites">kiting</a>, <a href="https://en.wikipedia.org/wiki/Juggling">juggling</a> and <a href="../categories/">other things that interest me</a>. Look around, <a href="../projects/">use my code</a> and <a href="../blog/feed.xml">subscribe to my feed</a> to enjoy reading the blog in the comfort of your feed reader.</p>
<p>While my website is available in English and German, most of my blog will be single language. Mostly in German, but occasionally in English.</p>
<h1>Newest Entries:</h1>

  
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell/">
        Die Freuden einer gut eingerichteten Shell
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-02-27">Thursday, February 27, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell/terminal.jpg" alt="Terminal"></p>
<p>Es fängt natürlich mit der Frage an: welche Shell?</p>
<p>Das ist sehr einfach zu beantworten. Auf MacOS ist die <a href="https://www.zsh.org">zsh</a> die Standard-Shell - und daher sollte man die auch benutzen. Artikel Fertig, vielen Dank fürs Lesen! 😅</p>
<p>Windows hat die <a href="https://de.wikipedia.org/wiki/PowerShell">PowerShell</a> - wer damit Arbeiten (muss) sollte sie lernen!</p>
<p>Die nackte Shell ist ziemlich schlecht konfiguriert, da die Möglichkeiten der Shell gar nicht ausgenutzt werden. Auf Linux-Distributionen ist es Standard, dass die Shell von der Distribution eingerichtet wird, daher kann man damit meistens schon gut arbeiten.</p>
<p>Aber für MacOS (und Windows) gibt es viel zu tun.</p>
<p>So sieht die zsh unkonfiguriert aus:</p>
<div class="hll"><pre><span></span>dwt@NB1321<span class="w"> </span>~<span class="w"> </span>%<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>Library/Favorites
dwt@NB1321<span class="w"> </span>Favorites<span class="w"> </span>%
</pre></div>
<p>Das ist schon gar nicht schlecht, denn man sieht einiges:</p>
<ul>
<li><code>dwt</code>: Welcher Nutzer man gerade ist. Wichtig, wenn man viel mit <code>sudo</code> arbeitet, damit man nicht versehentlich Kommandos als <code>root</code> mit zu vielen Rechten ausführt.</li>
<li><code>NB1321</code>: Auf welchem Rechner man gerade eingeloggt ist. Wichtig wenn man auf vielen Rechnern arbeitet und nicht</li>
<li>Den aktuellen Ordner in dem man ist (<code>Favorites</code>). Wichtig damit man z.B. nicht versehentlich die falschen Dateien löscht.</li>
<li>Der Prompt <code>%</code> trennt die Meta-Informationen von dem was man selbst eingibt.</li>
</ul>
<p>Da geht aber noch wesentlich mehr. Bei mir z.B. sieht der Prompt so aus:</p>
<div class="hll"><pre><span></span>~/C/P/m/api<span class="w"> </span>❄️<span class="w"> </span>🧪<span class="w"> </span>nix-shell-env<span class="w">   </span>🐍<span class="w"> </span>venv<span class="w"> </span>⛵️<span class="w"> </span>mkk-itsc-dev<span class="w"> </span><span class="o">(</span>api<span class="o">)</span><span class="w"> </span>🌱<span class="w"> </span>main<span class="w"> </span><span class="nv">$!</span><span class="w">  </span>4s
❯
</pre></div>
<p>Da ist enthalten:</p>
<ul>
<li><code>~/C/P/m/api</code> - nicht nur der aktuelle Ordner, sondern auch jeweils der Anfangsbuchstabe der darüber liegenden Ordner. Das liefert platzsparend viel mehr Kontext, wo man gerade ist. Super wenn man in vielen Projekten gleichnamige Ordner wie z.B. <code>etc</code>, <code>src</code> oder <code>dist</code> hat.</li>
<li><code>❄️ 🧪 nix-shell-env</code> Zeigt an, dass gerade eine 'dreckige' <a href="https://nixos.wiki/wiki/Development_environment_with_nix-shell">Nix-Shell</a> aktiv ist. Das verwende ich um Projek-spezifische Abhängigkeiten (Shell-Tools, bestimmte Vesionen von Python etc.) zu installieren die ich deklarativ im Projekt tracke. Gut vergleichbar mit Python-Virtual-Envs - aber eben für alles, nicht nur Python-Pakete. Dreckig ('impure') ist Sie, da nicht <em>nur</em> die Shell-Tools aus der Nix-Shell sichtbar sind, sondern auch alles andere was ich im Betriebsystem installiert habe.</li>
<li><code>🐍 venv</code> - zeigt an, dass gerade ein Python-Virtual-Env aktiv ist. Da ich hauptsächlich mit Pyton entwickle ist das natürlich entscheidend weil es bedeutet das ich die Projekt-Werkzeuge direkt verwenden kann, da sie im <code>$PATH</code> und <code>$PYTHONPATH</code> sind.</li>
<li><code>⛵️ mkk-itsc-dev (api)</code> zeigt an, dass ich mit dem <code>mkk-itsc-dev</code> Kubernetes Cluster verbunden bin, und den Namespace <code>api</code> aktiviert habe. Das ist mir sehr wichtig, damit ich nicht versehentlich mit <code>kubectl</code> Befehlen versehentlich den Produktiv-Cluster zerstöre. (Rate wieso mir das so wichtig ist…)</li>
<li><code>🌱 main $!</code> zeigt an, dass ich in einem Git-Repository bin, auf dem main branch, das ich dinge ge-'stash't habe (die vergisst man sonst sehr leicht) und das ich Änderungen habe die ich noch nicht commited habe. Hier gibt es <a href="https://starship.rs/config/#git-status">auch noch mehr informationen wenn das Repo den entsprechenden Zustand hat</a>.</li>
<li>Zuletzt sehe ich da das letzte Kommando 4 Sekunden gedauert hat. Das wird nur angezeigt wenn das letzte Programm mehr als 3 Sekunden gedauert hat und ist immer wiede ein hilfreiche Information um bei langlaufenden Prozesen zu verstehen ob es sich lohnt da etwas zu optimieren.</li>
</ul>
<p>Natürlich könnte man hier noch viel mehr anzeigen, je nachdem an was man gerade arbeitet. Ich habe hier eben die Informationen aufgenommen die ich am meisten benötige.</p>
<p>Jetzt kommt der Clou: Früher habe ich das alles von hand Konfiguriert. Das war ein ewiges und mühsammes gefummel um <code>$PS1</code> und konsorten so hinzufummeln das das alles funktioniert hat, und hat nie Spaß gemacht. Der Standard ist derzeit, das man einen Shell-Konfigurations-Framework wie <a href="https://ohmyz.sh">Oh-My-Zsh</a> oder <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> verwendet. Und die sind auch gut. Aber auch langsam, und komplex und kompliziert. Wenn man da mal etwas anders haben will dann gott bewahre wenn das nicht schon vorbereitet ist oder man darf sich nicht nur mit den Komplexitäten von <code>$PS1</code> auseinandersetzen, sondern auch noch damit wie genau dieser Framework das handhabt.</p>
<p>Inzwischen bin ich weiser geworden, und verwende <a href="https://starship.rs">Starship</a>. Damit kann ich meinen Prompt deklarativ in einer <code>.toml</code>-Datei konfigurieren und diesen auch mitnehmen wenn ich mal die Shell wechsle. (Was häufiger vorkommt als mir lieb ist). Und: Starship funktioniert auch mit der PowerShell.</p>
<p><a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell/starship.toml">So sieht meine Konfiguration aus</a></p>
<p>Wie richtet man das ein?</p>
<ol>
<li><code>brew install starship</code> (oder mit <a href="https://lix.systems">nix</a>)</li>
<li><code>nano ~/.zshrc</code> und am Ende <code>eval "$(starship init zsh)"</code> einfügen.</li>
<li>Konfigurationsdatei erstellen: <code>nano ~/.config/starship.toml</code> und z.b. <a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell/starship.toml">den Inhalt aus der Datei oben einfügen</a>.</li>
<li>Shell neu starten oder neues Terminal öffnen.</li>
</ol>
<p>Danke sagen für die grandiose Verbesserung eures Shell-Lebens bei mir nicht vergessen. 😅</p>

    </section>
    
      <footer>
        <a href="../blog/2025/2/die-freuden-einer-gut-eingerichteten-shell/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/">
        A Nix&#39;le in a Büchse und a goldigs Warteweile
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-02-08">Saturday, February 8, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="../blog/2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/nix-rabbit-hole.png" alt="Das Nix Hasenloch">
… ist ein schwäbisches Sprichwort und passt gar nicht so schlecht für die vielen schlechten Wortwitze die sich automatisch ergeben, wenn man anfängt, sich in das <a href="https://nix.dev">Nix Projekt</a> einzuarbeiten.</p>
<p>Zunächst mal die Karotte mit der ich mich ködern ließ:</p>
<ul>
<li>Deklarative Konfiguration von Software-Builds, System-Konfigurationen, und wenn man möchte auch Deployments z.B. in Kubernetes und was man sonst gerne möchte</li>
<li>Ein funktionaler Paket-Manager, das heißt: Jede Software kann ihre eigenen Abhängigkeiten in der passenden Version haben. Wenn ich mal ein Tool in der Version von vor 10 Jahren brauche - einfach zusätzlich installieren, ohne dass dadurch etwas gestört wird. Wenn ich mal eine neuere Version von etwas brauche als die aktuelle Distribution anbietet: Einfach installieren, ohne dass dadurch etwas gestört wird.</li>
<li>Rollback: Systemkonfiguration hat etwas kaputt gemacht? Einfach Rückgängig machen.</li>
<li>Update auf eine neue Version des Betriebssystems: Man kriegt fehlermeldungen für alle Konfigurationen die man vorgenommen hat die jetzt umbenannt wurden oder anders funktionieren. 🤯</li>
<li>Reproduzierbarkeit: Vollständige Erfassung der Inputs und Ablegen derselben in einem Lock-File.</li>
<li>Eine riesige Community, die beste Praktiken zum Betrieb von Linux (und mehr) Systemen <a href="https://repology.org/repositories/statistics/total">in die größte Software-Bibliothek kodiert, die wir bisher gesehen haben.</a></li>
</ul>
<p>Was sollte man da nicht mögen?</p>
<p>Auf MacOs gibt es mit <a href="https://github.com/LnL7/nix-darwin">nix-darwin</a> ein Projekt mit dem man die System-Konfiguration deklarativ vornehmen kann - und auch <a href="https://brew.sh">homebrew</a> (was sonst so gut wie gar nicht reproduzierbar ist) unter Kontrolle kriegt. Und wenn man möchte, verwaltet es einem auch die dotfiles.</p>
<p>Es gibt allerdings einen gewaltigen Nachteil: Das Ganze ist echt komplex und kompliziert. Und die Dokumentation ist nicht schlecht, aber könnte deutlich besser sein.</p>
<p>Wenn man diese Hürde überwindet, wird man mit einer erstaunlich kompakten und sehr schnell anzuwendenden System-Konfiguration belohnt. Damit kann man zum Beispiel auf einem Mac ein vollständig konfiguriertes System-Image für einen Raspberry Pi erstellen. Dann noch flaschen, starten und läuft! Oder auf meinem Mac Bauen, und via ssh auf dem RasPi deployen, ohne dort irgendwas zu machen was dessen CPU stresst.</p>
<p>Ich habe inzwischen angefangen, meine Rechner damit zu verwalten und konfigurieren.</p>
<ul>
<li><a href="https://github.com/dwt/nix-darwin-config">Mein Rechner (nix-darwin)</a></li>
<li><a href="https://github.com/dwt/home-servers">Mein Homelab (nixos)</a></li>
<li><a href="https://github.com/dwt/home-automation">Meine Heimautomatisierung (python)</a></li>
</ul>
<h1>Nix ist vielleicht nichts für dich…</h1>
<p>… aber wenn Du ein bisschen nerdig bist, und gerne auf der Kommandozeile lebst, infrastruktur as Code magst oder lernen magst und DevOps für dich eh normal ist. Dann könnte Nix auch für dich genau das richtige sein.</p>
<h1>Wie lernt man Nix am besten?</h1>
<p>Was mir beim Lernen von Nix gefehlt hat, wäre eine Leitlinie gewesen, in welcher Reihenfolge ich mich an die vielen Features von Nix heran tasten sollte. Eine Reihenfolge, die sicherstellt, das die Lernkurve zu jedem Zeitpunkt erträglich bleibt. Und besonders wichtig: Die Sicherstellt, das zu jedem Zeitpunkt sichtbar ist wie cool und wertvoll diese Technologie ist. Sonst läuft man Gefahr, ob der steilen Lernkurve abzuspringen.</p>
<p>Das hätte ich gerne gehabt: Wenn du anfängst Nix zu lernen, dann am besten in dieser Reihenfolge:</p>
<h2>1. Schritt: Installieren, ohne was bestehendes kaputt zu machen</h2>
<p>Zuerst sollte man Nix neben dem aktuellen OS installieren. Der Standard ist der <a href="https://docs.determinate.systems/getting-started/individuals/">Determinate Installer</a>, aber ich mag <a href="https://lix.systems">das Lix Projekt lieber, da es schneller ist</a>. Alternativ ist auch <a href="https://nixos.org/download/#nix-install-docker">der Nix-Docker-Container super um es mal auszuprobieren</a>. Wenn man möchte, <a href="https://nixos.org/download/#nix-install-linux">kann man Nix (auf Linux) auch einfach in einen Ordner installieren und so verwenden (siehe "Single-User Mode")</a>. Das würde ich aber nur für ein paar Experimente empfehlen. Sowohl der Determinate als auch der Lix-Installer haben sehr gute Uninstaller die das Projekt auch wieder komplett entfernen können.</p>
<h2>2. Schritt: Imperativ verwenden</h2>
<p>Nix erlaubt es jederzeit ein Paket zu benutzen, ohne es zu installieren. Das ist eine Konsequenz davon wie der Paket-Manager aufgebaut ist. Ein Paket kann 'im <code>/nix/store/</code> sein' - ohne das es aktiv ist. Und der Befehl <code>nix run nixpkgs#fzf</code> startet es dann einfach - ohne es zu installieren. Alternativ gibt es auch <code>nix shell nixpkgs#fzf</code>. Damit erhällt man eine Shell, in der <code>fzf</code> installiert ist. Schließt man die Shell, ist es auch wieder weg. 😳</p>
<p>Dass ist der Hammer, weil man so Pakete ohne Reue ausprobieren kann. Ohne Sorgen, dass doch noch irgendwelche Abhängigkeiten evtl. auf dem System herum gurken und man vergessen könnte ein Experiment wieder zu entfernen. Und das beste: Auch später wird man dieses Feature die ganze Zeit verwenden.</p>
<p>Vorsicht vor <code>nix-env</code> und <code>nix profile</code> - das ist das Äquivalent zu dem wie man mit <code>homebrew</code>  und anderen Paketmanagern Pakete installieren würde. Diese sollte man so selten wie möglich verwenden. Besser ist…</p>
<h2>3. Schritt: Entwicklungsumgebungen <code>shell.nix</code></h2>
<p>Das, was <code>nix shell nixpkgs#fzf</code> macht, kann man auch in eine Datei schreiben, und damit einfach in ein Repo mit einchecken. Schon hat man Deklarativ die ganzen Tools im Repo dokumentiert, die man braucht um mit einem Projekt zu arbeiten. Bonus: Ich kann für jedes Projekt eigene Versionen der Abhängigkeiten haben (wenn ich das brauche). Python-Virtual-Envs auf Steroiden!</p>
<p>Hier ein Beispiel:</p>
<div class="hll"><pre><span></span><span class="p">{</span>
  pkgs <span class="o">?</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{</span> <span class="p">},</span>
<span class="p">}:</span>
pkgs<span class="o">.</span>mkShell <span class="p">{</span>
  <span class="ss">buildInputs</span> <span class="o">=</span> <span class="k">with</span> pkgs<span class="p">;</span> <span class="p">[</span>
    <span class="c1"># Add your build inputs here</span>
    pkgs<span class="o">.</span>python313
    pkgs<span class="o">.</span>uv
  <span class="p">];</span>
  <span class="ss">env</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">UV_PYTHON</span> <span class="o">=</span> pkgs<span class="o">.</span>python313<span class="p">;</span>
    <span class="ss">UV_DOWNLOAD_PYTHON</span> <span class="o">=</span> <span class="s2">&quot;never&quot;</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>Wenn man das mit <code>nix-shell</code> aufruft, dann hat man diese Python-Version zur Hand. <code>uv</code> verwendet diese und lädt selber keine Python-Versionen herunter. Nice! Extra nice: mit <code>nix-shell --pure</code>  hat man eine Shell in der <em>nur</em> das sichtbar ist was in dem <code>shell.nix</code> steht, und man kriegt Fehler für alles was man verwendet und in der <code>shell.nix</code> vergessen hat. 🤯</p>
<p>Bonus: <a href="https://direnv.net">Direnv</a> verwenden um automatisch die <code>shell.nix</code> und das <code>.env</code> zu laden. Dazu <a href="https://github.com/ajeetdsouza/zoxide">zoxide</a> um schnell in der Shell zwischen vielen Projekten hin und zu springen. Eine richtig geniale Entwicklungsumgebung.</p>
<p>Ich empfehle erst mal eine weile auf diesem Niveau zu bleiben, denn das ist schon ziemlich cool!</p>
<h2>4. Schritt: Mehr Tooling um besser mit Nix klar zu kommen</h2>
<ul>
<li>Pakete findet man am besten über <a href="https://search.nixos.org/packages">die Webseite search.nixos.org</a> - aber ich mag eigentlich in der shell suchen. <code>nix run nixpkgs#nh search ut1999</code> funktioniert besser als alles was ich sonst bisher getestet habe.</li>
<li>Anzeigen was gerade installiert ist und wieso ist aufgrund der Architektur von nix gar nicht so einfach. <code>nix run nixpkgs#nix-tree</code> aproximiert das und gibt einen guten überblick darüber was man auf dem System hat.</li>
<li><code>nom</code> - der <a href="https://github.com/maralorn/nix-output-monitor">Nix-Output-Monitor</a> <code>nix run nixpkgs#nix-output-monitor</code> macht den output von längeren nix builds viel informativer und spannender. Verwenden kann man das so: <code>nix run $something |&amp; nix run nixpkgs#nix-output-monitor</code></li>
<li><code>nix store gc</code> um alles zu löschen, was man mal testweise runtergeladen hat und nicht mehr auf der Platte braucht. (Einer Der Nachteile von Nix: Es verbraucht schnell <em>viel</em> Plattenplatz).</li>
</ul>
<h2>5. Schritt: Tief in das Hasenloch fallen</h2>
<p>Jetzt gibt es verschiedene Sachen die man sich anschauen könnte</p>
<ul>
<li><a href="https://nix.dev/manual/nix/2.24/language/index.html">Die Nix Sprache lernen</a> - die Voraussetzung für fast alles was danach kommt, also gut investierte Zeit. Und es ist eine wirklich kleine Sprache - auch wenn <a href="https://github.com/NixOS/nixpkgs">die 'Standard-Bibliothek' (meiner Meinung nach das NixPKGs Repository)</a> alles andere als klein ist.</li>
<li><a href="https://devenv.sh">devenv</a> um Entwicklungsumgebungen kurz und Knackig und mit allen Features deklarativ zu beschreiben und ins Projekt eingecheckt zu bekommen.</li>
<li><a href="https://nixos-and-flakes.thiscute.world">Flakes - der Standard in der Nix-Community, mit der Abhängigkeits-Versionen festgeschrieben werden</a>. Also wie checke ich die genauen git commit hashes die ich verwendet habe um alle meine Software zu bauen ins Repo mit ein. Damit kann man ein Projekt auch nach Jahren sehr einfach verlässlich wieder bauen.</li>
<li><a href="https://github.com/pyproject-nix/uv2nix">uv2nix - wie man Python-Projekte Nix-ifiziert</a></li>
<li><a href="https://github.com/LnL7/nix-darwin">nix-darwin</a> um ein MacOS System so deklarativ zu verwalten, wie das unter NixOS geht. (OK, Apple setzt da grenzen, aber das ist trotzdem sehr cool).</li>
<li><a href="https://nix-community.github.io/home-manager/">home-manager</a> um dotfiles zu verwalten und auf Benutzer-Ebene alles zu konfigurieren.</li>
<li>Quasi alles von <a href="https://github.com/nix-community/awesome-nix?tab=readme-ov-file">Awesome-Nix</a>.</li>
<li>Und so viele Projekte mehr, die man sich anschauen könnte…</li>
</ul>

    </section>
    
      <footer>
        <a href="../blog/2025/2/a-nixle-in-a-buechse-und-a-goldigs-warteweile/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">
        Grundlegende Funktionen und Einstellungen des Terminals
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2024-11-25">Monday, November 25, 2024</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p>Der Terminal-Emulator ist ein zentrales Werkzeug, mit dem wir Entwickler mit unseren Rechnern interagieren. Jedes bisschen Wissen und jede Effizienz, die du hier gewinnst, zahlt sich in kürzester Zeit hundertfach aus.</p>
<p>Natürlich gibt es viele Terminals, wie <a href="https://iterm2.com">iTerm2</a>, <a href="https://alacritty.org">Alacritty</a> oder <a href="https://sw.kovidgoyal.net/kitty/">Kitty</a>. Aber ich finde, diese solltest du nur verwenden, wenn sie deinen Workflow wirklich verbessern. Und dafür musst du zuerst wissen, was Apple standardmäßig mitliefert.</p>
<p>Das Schöne am Terminal ist, dass du unglaublich wenig anpassen musst, da es von Haus aus sehr gut funktioniert.</p>
<p>Ich nutze das eingebaute Terminal von macOS mit nur zwei (!) Konfigurationsanpassungen.</p>
<h2>Wortweise Löschen</h2>
<p><img src="../blog/2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/delete-word.png" alt="Wortweise Löschen"></p>
<p>Die erste wirklich wichtige Anpassung für mich ist, dass ⌥-⌫ (Alt-Delete) als Standard-Keybinding gesetzt wird, damit wortweise nach links gelöscht wird. Damit passt du das Terminal an den Mac-Standard an, der in fast allen anderen Programmen ebenfalls funktioniert.</p>
<p>So geht's:</p>
<ol>
<li>Terminal → Einstellungen öffnen (⌘-,).</li>
<li>Auf der linken Seite alle Profile auswählen, damit alle Einstellungen gleichzeitig bearbeitet werden.</li>
<li>Auf der rechten Seite → "Tastatur" auswählen.</li>
<li>Einen neuen Shortcut hinzufügen.</li>
<li>Die Felder wie im Screenshot ausfüllen. <code>\027</code> steht für <strong>⌃-w</strong> (<code>ctrl-w</code>), den Standard-Shortcut für wortweises Löschen in der Shell.</li>
</ol>
<h2>Ausgabe navigieren, selektieren und löschen</h2>
<p>Die nächst-wichtigsten Shortcuts sind:</p>
<ul>
<li><strong>⌘-N</strong> / <strong>⌘-T</strong> / <strong>⌘-W:</strong> Alles Standard, aber trotzdem meine meistbenutzten Shortcuts.</li>
<li><strong>⌘-↑</strong> und <strong>⌘-↓:</strong> Zum Anfang des vorherigen bzw. nächsten ausgeführten Befehls springen. Das ist super praktisch, um schnell nachzusehen, was die vorherigen Kommandos waren.</li>
<li><strong>⌘-Shift-↑</strong> und <strong>⌘-Shift-↓:</strong> Wie oben, aber selektiert zusätzlich. Damit kannst du schnell einen Befehl und dessen Ausgabe kopieren. Das ist super praktisch, um Anleitungen zu schreiben oder einem Kollegen zu zeigen, wie etwas gemacht wurde.</li>
<li><strong>⌘-L:</strong> Löscht nur die Ausgabe des letzten Kommandos. Sehr praktisch, um ein nicht mehr benötigtes Shell-Experiment zu entfernen – besonders bei Fehlern mit viel Output. Oft nutze ich das, wenn ich zuerst eine Hilfe anzeige und dann darunter verschiedene Experimente ausführe, um die richtigen Flags zu finden. (Genauer: <strong>⌘-L</strong> löscht vom Ende bis zur aktuellen Selektion und funktioniert daher hervorragend mit <strong>⌘-↑</strong>.)</li>
<li><strong>⌘-K:</strong> Terminal löschen. Die nukleare Option – sie löscht alles im aktuellen Terminal. Großer Nachteil: Was weg ist, ist weg. Also nicht benutzen, wenn du den Output noch brauchst. Dennoch ist dies einer meiner am häufigsten benutzten Shortcuts.</li>
</ul>
<h2>Unbegrenzter Puffer</h2>
<p><img src="../blog/2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/unlimited-buffer.png" alt="Unbegrenzter Puffer"></p>
<p>Die zweite Anpassung, die ich vornehme, ist, den Scrollback-Puffer auf unbegrenzt zu stellen, damit ich die Ausgabe von langen Kommandos nicht verliere. Das geht so:</p>
<ol>
<li>Terminal → Einstellungen öffnen (<strong>⌘-,</strong>).</li>
<li>Wie zuvor alle Profile auswählen.</li>
<li>Auf der rechten Seite → "Fenster" → "Zeilenpuffer" auf „auf den verfügbaren Speicher begrenzen“ stellen.</li>
</ol>
<h2>Fazit</h2>
<p>Mit diesen Shortcuts kannst du ultraschnell zwischen den letzten Kommandos navigieren, deren Ausgabe selektieren (und kopieren) oder löschen.</p>
<p>Diese Anpassungen und Shortcuts sind für mich auch einer der Hauptgründe, warum ich die eingebauten Terminals in IDEs nicht gerne benutze. Denn dort funktionieren sie oftmals nicht gut.</p>
<p>Viele dieser Einstellungen und Shortcuts gibt es auch auf der Ebene der Shell. Der Vorteil, sie über das Terminal zu konfigurieren, ist, dass diese Shortcuts auch auf anderen Servern oder in Docker- bzw. Kubernetes-Containern funktionieren.</p>
<p>Ich hoffe, diese Tipps helfen dir, das Terminal noch besser zu nutzen.</p>
<p>Kennst du weitere nützliche Shortcuts oder Einstellungen, die ich nicht erwähnt habe? Hast du Fragen zu den vorgestellten Tipps? Lass es mich wissen!</p>
<p>Happy Shelling!</p>

    </section>
    
      <footer>
        <a href="../blog/2024/11/grundlegende-funktionen-und-einstellungen-des-terminals/">weiterlesen…</a>
      </footer>
    
  </article>

  
  
  <a href="../blog/">Weitere Beiträge…</a>

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2025 <a href="work/">Martin Häcker</a></span>
  </li>
  
    
    <li class="nav-item imprint">
      <a class="nav-link" href="meta/#imprint">
        Imprint
      </a></li>
  
    
    <li class="nav-item privacy-policy">
      <a class="nav-link" href="meta/#privacy-policy">
        Privacy Policy
      </a></li>
  
    
    <li class="nav-item colophon">
      <a class="nav-link" href="meta/#colophon">
        Colophon
      </a></li>
  
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="../blog/feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    <a class="nav-link" 
      rel="license" 
      target="_blank" 
      href="https://creativecommons.org/licenses/by-sa/4.0/deed"
    >
      <img 
        src="/static/cc-by-sa-88x31.png"
        alt="Creative Commons Attribution - Share Alike 4.0 International Lizense"
      >
    </a>
  </li>
</ul>
    </footer>
  </body>
</html>
