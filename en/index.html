
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="../static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/pygments.css">
    <title>🏠</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin Häckers Blog Artikel" href="../blog/feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="./" class="navbar-brand active">🏠<span class="sr-only">(ausgewählt)</span></a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="work/" class="nav-link">Professional software development</a></li>
    
      <li class="nav-item "><a href="projects/" class="nav-link">Projects</a></li>
    
      <li class="nav-item "><a href="publications/" class="nav-link">Publications and talks</a></li>
    
      <li class="nav-item "><a href="blog/" class="nav-link">Blog</a></li>
    
      <li class="nav-item "><a href="categories/" class="nav-link">Categories</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="../">🇩🇪</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="./">🇬🇧</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

<a class="breadcrumb-item active" href="./">🏠</a>

</nav>
    </header>
    <article class="page  homepage container-fluid">
      
  <h1>Welcome!</h1>
<p>I'm <a href="../work">Martin Häcker</a>, a software developer with more than 20 years of experience. I can assist with <a href="../work">all aspects of professional software development</a>.</p>
<p>My blog is about <a href="../categories/code/">Software</a>, <a href="../categories/liquid/">Liquid Democracy</a>, <a href="../categories/go/">Go / Baduk / Weiqi</a>, <a href="../categories/cucina/">Kochen</a>, <a href="http://gropies.de/">choir singing</a>, <a href="https://en.wikipedia.org/wiki/Bouldering">bouldering</a>, <a href="https://en.wikipedia.org/wiki/Cue_sports">billiard</a>, <a href="https://en.wikipedia.org/wiki/Paragliding">paragliding</a>, <a href="https://en.wikipedia.org/wiki/Category:Kites">kiting</a>, <a href="https://en.wikipedia.org/wiki/Juggling">juggling</a> and <a href="../categories/">other things that interest me</a>. Look around, <a href="../projects/">use my code</a> and <a href="../blog/feed.xml">subscribe to my feed</a> to enjoy reading the blog in the comfort of your feed reader.</p>
<p>While my website is available in English and German, most of my blog will be single language. Mostly in German, but occasionally in English.</p>
<h1>Newest Entries:</h1>

  
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/9/warum-man-backups-und-disaster-recovery-zusammen-denken-sollte/">
        Backup ohne verprobte Recovery ist wertlos – 5 Gründe
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-09-29">Monday, September 29, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="../blog/2025/9/warum-man-backups-und-disaster-recovery-zusammen-denken-sollte/backup-ohne-recovery.png" alt="Backup und Recovery"></p>
<p>Auf der DevOpsCon 25 in Berlin habe ich viel aus dem Vortrag <a href="https://devopscon.io/devsecops/backup-disaster-recovery/">Backup and Disaster Recovery: Business as Usual or What Needs to Change Now? - DevOps Conference &amp; Camps</a> gezogen. Zum technischen Inhalt gehe ich noch mal Separat ein, aber zuerst wollte ich meine Schlüssel-Lernergebnisse auf einer sehr hohen Flughöhe mitbringen.</p>
<h2>1. Backups ohne Restore sind nur Datenfriedhöfe</h2>
<p>Ein Backup ist kein Wert an sich. Es ist nur die Basis für Geschäftskontinuität – erst der funktionierende Restore bringt das Unternehmen zurück ins Geschäft.</p>
<h2>2. Zeit entscheidet über Resilienz</h2>
<p>Recovery Time Objective (RTO) ist der kritische Faktor – nicht die schiere Menge oder Existenz von Kopien. Entscheidend ist: Wie lange darf welcher Teil des Geschäfts ausfallen, bis es ernsthafte Schäden nimmt?</p>
<h2>3. Kontinuierlicher Minimal-Restore trennt Dauer von Ausfallzeit</h2>
<p>Ein innovativer Ansatz ist, kontinuierlich eine schlanke, nicht skalierte Version der Systeme aus den Backups hochzufahren. Damit lässt sich jederzeit beweisen: Restore funktioniert. Und: Die Dauer des eigentlichen Restore-Vorgangs aus den Backups kann nahezu beliebig sein, ohne wesentlich das RTO zu gefährden.</p>
<h2>4. Vorhersagbare Skalierung statt unberechenbarer Wiederanlauf</h2>
<p>Im Notfall geht es nicht darum, <em>ob</em> das Backup läuft, sondern <em>wie schnell</em> man wieder auf ausreichende Kapazität kommt. Wer Skalierung auf Abruf plant, kennt die Antwort: „In X Minuten / Stunden ist die  Leistung verfügbar.“ Das macht den Unterschied zwischen Chaos und geplanter Resilienz.</p>
<h2>5. Kosteneffizienz und Compliance in einem</h2>
<p>Statt teurer Standby-Infrastruktur entsteht ein Modell, das laufend minimale Kosten verursacht, aber im Ernstfall sofort hochskaliert. Dazu kommt: Unternehmen erfüllen so auch regulatorische Anforderungen nach nachweisbarer Wiederanlauffähigkeit.</p>
<p><strong>Fazit:</strong>
Backups sind nur der Anfang. Erst wenn Restore und Disaster Recovery gemeinsam gedacht werden – mit kontinuierlichem Minimal-Restore und skalierbarer Infrastruktur – entsteht echte Business-Kontinuität.</p>

    </section>
    
      <footer>
        <a href="../blog/2025/9/warum-man-backups-und-disaster-recovery-zusammen-denken-sollte/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/">
        Textbearbeitung auf der Shell: grep, cut, awk, sed und tr
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-09-25">Thursday, September 25, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="../blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/tr-in-action.png" alt="`tr` in aktion"></p>
<p>Diese fünf kleinen Tools sind echte Arbeitspferde für jeden, der mit Text auf der Kommandozeile arbeitet. Sie haben viele Optionen – aber man braucht nicht alles zu kennen. Schon mit ein paar Grundbefehlen kann man 80 % der typischen Aufgaben lösen.</p>
<h3>1. <code>grep</code> – Zeilen finden</h3>
<p>grep filtert Textzeilen anhand von Mustern. Praktisch, wenn man in langen Outputs schnell das Relevante sehen will.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Textzeilen ausgeben, die ein Wort enthalten</td>
<td><code>grep PATTERN</code></td>
<td>`cat protokoll.txt</td>
<td>grep "Fehler"`</td>
</tr>
<tr>
<td>Zeilen ausschließen</td>
<td><code>grep -v PATTERN</code></td>
<td><code>grep -v "^#" protokoll.txt</code></td>
</tr>
<tr>
<td>In einem ganzen Projektbaum nach</td>
<td><code>grep -r PATTERN DIR</code></td>
<td><code>grep -r "TODO" src/</code></td>
</tr>
</tbody>
</table>
<p><strong>Tipps</strong></p>
<ul>
<li><code>-i</code> ignoriert Groß/Kleinschreibung</li>
<li><code>-e</code> aktiviert Reguläre Ausdrücke (unter linux gibt es noch <code>-P</code> für Perl-kompatible Regex)</li>
</ul>
<p>Kombinationen über Pipes machen grep besonders stark:</p>
<div class="hll"><pre><span></span>grep<span class="w"> </span>-r<span class="w"> </span>-P<span class="w"> </span><span class="s2">&quot;def \w*\(&quot;</span><span class="w"> </span>.<span class="w"> </span>--after-context<span class="w"> </span><span class="m">30</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-v<span class="w"> </span><span class="s2">&quot;bar&quot;</span>
</pre></div>
<p>Für große Projekte lohnt sich ripgrep (rg), weil es schneller ist, <code>.gitignore</code> respektiert und reguläre Ausdrücke standardmäßig aktiviert.</p>
<h3>2. <code>cut</code> – Spalten und Zeichen</h3>
<p><code>cut</code> schneidet Spalten oder Zeichen aus Textzeilen heraus. Funktioniert am besten, wenn der Trenner ein einzelnes Zeichen ist.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spalte 2 eine CSV <sup class="footnote-ref" id="fnref-csv"><a href="#fn-csv">1</a></sup></td>
<td><code>-d ',' -f 2</code></td>
<td><code>cut -d ',' -f 2 daten.csv</code></td>
</tr>
<tr>
<td>Zeichen 5‑10 einer Zeile</td>
<td><code>-c 5-10</code></td>
<td><code>cut -c 5-10 string.txt</code></td>
</tr>
<tr>
<td>Mehrere Felder</td>
<td><code>-f 1,3,5</code></td>
<td><code>cut -d ';' -f 1,3,5 daten.txt</code></td>
</tr>
</tbody>
</table>
<p>Bei Whitespace-getrennten Daten stößt cut an Grenzen – da ist <code>awk</code> besser.</p>
<h3>3. <code>awk</code> – Felder und Muster</h3>
<p><code>awk</code> versteht Texte als Felder, getrennt durch Whitespace oder ein angegebenes Zeichen. Wenn man möchte, kann man mit <code>awk</code> Text-Dateien fast wie Datenbanken abfragen, aber für den Anfang:</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spalten ausgeben</td>
<td><code>{print $1, $3}</code></td>
<td><code>awk '{print $1, $3}' daten.txt</code></td>
</tr>
<tr>
<td>Letzte Spalte ausgeben</td>
<td><code>{print $NF}</code></td>
<td><code>awk '{print $NF}' daten.txt</code></td>
</tr>
<tr>
<td>Summe einer Spalte</td>
<td><code>{s+=$2} END {print s}</code></td>
<td><code>awk '{s+=$2} END {print s}' zahlen.txt</code></td>
</tr>
</tbody>
</table>
<p><strong>Nützliche Variablen</strong></p>
<ul>
<li><code>NF</code> = Anzahl Felder in der Zeile</li>
<li><code>NR</code> = aktuelle Zeilennummer</li>
</ul>
<h3>4. <code>sed</code> – Suchen und Ersetzen</h3>
<p><code>sed</code> ist ein Stream-Editor: ideal für Ersetzungen und einfache Transformationen.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ersetzen</td>
<td><code>s/alt/neu/g</code></td>
<td><code>sed 's/Fehler/Warning/g' log.txt</code></td>
</tr>
</tbody>
</table>
<p>Vorsicht: Nie direkt in die gleiche Datei schreiben mit &gt; – sonst überschreibst du sie, bevor sie gelesen wurde. <strong>DAMIT HABE ICH SCHON DATEN VERLOREN</strong> Stattdessen:</p>
<div class="hll"><pre><span></span>sed<span class="w"> </span>-i<span class="w"> </span><span class="s1">&#39;s/alt/neu/g&#39;</span><span class="w"> </span>datei.txt<span class="w">   </span><span class="c1"># Direkt in der Datei ändern</span>
</pre></div>
<h3>5. <code>tr</code> – Zeichen übersetzen</h3>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Groß→Klein</td>
<td><code>tr [:upper:][:lower:]</code></td>
<td><code>tr '[:upper:]' '[:lower:]' &lt; input.txt</code></td>
</tr>
<tr>
<td>Leerzeichen löschen</td>
<td><code>tr -d ' '</code></td>
<td><code>tr -d ' ' &lt; file</code></td>
</tr>
<tr>
<td>ROT13 (Caesar‑Shift)</td>
<td><code>tr 'a-z' 'n-za-m'</code></td>
<td><code>tr 'a-z' 'n-za-m' &lt; text.txt</code></td>
</tr>
<tr>
<td>Mehrere Zeichen gleichzeitig</td>
<td><code>tr 'abc' 'ABC'</code></td>
<td><code>tr 'abc' 'ABC' &lt; input.txt</code></td>
</tr>
</tbody>
</table>
<p>Beispiel: <code>$PATH</code> lesbarer machen:</p>
<div class="hll"><pre><span></span>❯<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$PATH</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>nl
</pre></div>
<h2>Fazit</h2>
<ul>
<li><strong><code>grep</code></strong>: Zeilen nach Mustern filtern</li>
<li><strong><code>cut</code></strong>: Spalten oder Zeichen ausschneiden.</li>
<li><strong><code>awk</code></strong>: Felder flexibel verarbeiten und berechnen.</li>
<li><strong><code>sed</code></strong>: Ersetzen und transformieren</li>
<li><strong><code>tr</code></strong>: Zeichen umwandeln oder löschen</li>
</ul>
<p>👉 Zusammengeschaltet mit Pipes (<code>|</code>) werden diese Tools zu einem Schweizer Taschenmesser für Textbearbeitung – schnell, skriptbar und überall verfügbar.</p>
<div class="footnotes">
<hr>
<ol><li id="fn-csv"><p>CSV = Comma-Separated Values, kann natürlich auch maskierte Kommas in dem Wert enthalten, was dieser Befehl geflissentlich ignoriert oder falsch macht. Verwendet zum CSV-Parsen also bitte nicht diesen Shell-Befehl. Dieser Befehle sind dafür da, auf der Shell schnell mal in eine Datei hineinzuschauen. Wenn das Ergebnis gut genug ist, kann man es auch weiter verarbeiten.<a href="#fnref-csv" class="footnote">&#8617;</a></p></li>
</ol>
</div>

    </section>
    
      <footer>
        <a href="../blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/">
        Arbeiten mit JSON &amp; YAML auf der Shell
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-08-25">Monday, August 25, 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="../blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/yless.png" alt="yaml ganz angenem auf der Shell"></p>
<p>Arbeiten mit strukturierten Datenformaten auf der Shell kann anstrengend sein – <strong>wenn man noch nicht die richtigen Tools dafür hat</strong>.
Ob JSON aus einer API, YAML aus Kubernetes-Manifests oder riesige Logfiles – ohne passende Helferlein endet man schnell bei unübersichtlichem <code>grep</code>, <code>less</code> und Copy&amp;Paste.</p>
<p>Zum Glück gibt es eine Reihe von Werkzeugen, die genau dafür gemacht sind:</p>
<ul>
<li><strong>jq</strong> – JSON lesen, filtern und transformieren – <a href="https://jqlang.org">https://jqlang.org</a></li>
<li><strong>jo</strong> – JSON in der Shell erzeugen – <a href="https://github.com/jpmens/jo">https://github.com/jpmens/jo</a></li>
<li><strong>yq</strong> – YAML lesen, bearbeiten und konvertieren – <a href="https://mikefarah.gitbook.io/yq/">https://mikefarah.gitbook.io/yq/</a></li>
<li><strong>jless / yless</strong> – interaktiv in JSON/YAML navigieren – <a href="https://jless.io">https://jless.io</a></li>
</ul>
<p>In diesem Beitrag stelle ich euch diese Tools vor – mit Beispielen, die ihr direkt in eurer eigenen Shell ausprobieren könnt.</p>
<hr>
<h2>jq – der Klassiker für JSON</h2>
<p>Das vermutlich bekannteste und am weitesten verbreitete Tool für JSON ist <a href="https://jqlang.org"><strong><code>jq</code></strong></a>.
Es ist so etwas wie der <em>Schweizer Taschenmesser</em> für JSON:</p>
<ul>
<li>formatiert unlesbare Minified-JSON-Dateien,</li>
<li>extrahiert gezielt Werte,</li>
<li>filtert und transformiert Daten,</li>
<li>eignet sich für einmalige Ad-hoc-Analysen genauso wie für Skripte.</li>
</ul>
<p>Ein einfaches Beispiel: JSON schön formatieren:</p>
<pre><code>$ cat data.json
{"user":{"id":42,"name":"Alice"},"active":true}
$ cat data.json | jq # oder `jq &lt; data.json`
</code></pre>
<div class="hll"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;user&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;active&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>So schnell wird aus einem unübersichtlichen Einzeiler eine lesbare Struktur.</p>
<p>Mann kann es aber auch super in scripten verwenden um Daten aus json zu extrahieren:</p>
<div class="hll"><pre><span></span>get_current_gitlab_token<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>kubectl<span class="w"> </span>get<span class="w"> </span>secret<span class="w"> </span><span class="nv">$SECRETNAME</span><span class="w"> </span>-n<span class="w"> </span><span class="nv">$INITIALNAMESPACE</span><span class="w"> </span>-o<span class="w"> </span>json<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>jq<span class="w"> </span>-r<span class="w"> </span><span class="s1">&#39;.data[&quot;.dockerconfigjson&quot;]&#39;</span><span class="w"> </span><span class="m">2</span>&gt;/dev/null<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>base64<span class="w"> </span>--decode<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>jq<span class="w"> </span>-r<span class="w"> </span><span class="s1">&#39;.auths[&quot;registry.gitlab.com&quot;].password&#39;</span><span class="w"> </span><span class="m">2</span>&gt;/dev/null
<span class="o">}</span>
</pre></div>
<p>Oder um in einem JSON-File Daten einzutragen:</p>
<div class="hll"><pre><span></span>kubectl<span class="w"> </span>get<span class="w"> </span>secrets<span class="w"> </span>shipa-certificates<span class="w"> </span>-o<span class="w"> </span>json<span class="w"> </span><span class="se">\</span>
<span class="w">        </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="s2">&quot;.data[\&quot;ca.pem\&quot;] |= \&quot;</span><span class="nv">$CA_CERT</span><span class="s2">\&quot;&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">        </span><span class="p">|</span><span class="w"> </span>kubectl<span class="w"> </span>apply<span class="w"> </span>-f<span class="w"> </span>-
</pre></div>
<p><code>jq</code> kann noch viel mehr. Wer das Werkzeug noch nicht kennt sollte unbedingt ein paar Minuten investieren um <a href="https://jqlang.org/tutorial/">das Tutorial</a> querzulesen, und dann bei der nächsten Einsatzmöglichkeit gezielt nach der Syntax schauen. Pro tip: KI's können diese Syntax prima, und <code>jless</code> (kommt gleich) kann diese auch generieren.</p>
<hr>
<h2>jo – JSON in der Shell erzeugen</h2>
<p>Während <code>jq</code> ideal zum Lesen und Transformieren ist, eignet sich <strong><code>jo</code></strong> perfekt, um JSON direkt in der Shell zu erstellen. Damit lassen sich Testdaten oder API-Payloads schnell zusammenbauen.</p>
<p>Ein einfaches Beispiel:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span><span class="nv">name</span><span class="o">=</span>Alice<span class="w"> </span><span class="nv">age</span><span class="o">=</span><span class="m">30</span><span class="w"> </span><span class="nv">active</span><span class="o">=</span><span class="nb">true</span>
</pre></div>
<p>Ausgabe:</p>
<div class="hll"><pre><span></span><span class="p">{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="nt">&quot;age&quot;</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="nt">&quot;active&quot;</span><span class="p">:</span><span class="kc">true</span><span class="p">}</span>
</pre></div>
<p>Auch Arrays sind möglich:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span>-a<span class="w"> </span>red<span class="w"> </span>green<span class="w"> </span>blue
</pre></div>
<p>➜ <code>["red","green","blue"]</code></p>
<p>Verschachtelte Objekte:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span><span class="nv">user</span><span class="o">=</span><span class="k">$(</span>jo<span class="w"> </span><span class="nv">name</span><span class="o">=</span>Alice<span class="w"> </span><span class="nv">id</span><span class="o">=</span><span class="m">42</span><span class="k">)</span><span class="w"> </span><span class="nv">project</span><span class="o">=</span>Demo
</pre></div>
<p>➜ <code>{"user":{"name":"Alice","id":42},"project":"Demo"}</code></p>
<p>Das eignet sich sehr gut für schnelle <code>curl</code>-Requests, aber insbesondere auch für shell scripte in denen inline json sonst sehr schnell sehr unübersichtlich wird:</p>
<div class="hll"><pre><span></span>curl<span class="w"> </span>-X<span class="w"> </span>POST<span class="w"> </span>-H<span class="w"> </span><span class="s2">&quot;Content-Type: application/json&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">     </span>-d<span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>jo<span class="w"> </span><span class="nv">username</span><span class="o">=</span>dev<span class="w"> </span><span class="nv">password</span><span class="o">=</span>secret<span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">     </span>https://example.com/api/login
</pre></div>
<hr>
<h2>yq – YAML lesen und bearbeiten</h2>
<p>YAML verwenden wir überall, am meisten habe ich in Kubernetes damit zu tun. <a href="https://mikefarah.gitbook.io/yq/"><strong><code>yq</code></strong></a> ist das Werkzeug der Wahl, um YAML-Dateien zu lesen, zu durchsuchen und zu editieren. Die Syntax ist sehr nahe an <code>jq</code>, das Werkzeug kann neben YAML aber auch JSON, TOML und XML verarbeiten, und zwischen diesesn Konvertieren. Im wesentlichen kann es das gleiche wie <code>jq</code>, eben auch für YAML.</p>
<hr>
<h2>jless &amp; yless – interaktiv stöbern</h2>
<p>Wenn Dateien zu groß oder zu komplex werden, helfen <a href="https://jless.io"><strong><code>jless</code></strong></a> und <strong><code>yless</code></strong> (ein <code>alias yless=jless --yaml</code>. Sie bieten eine interaktive Ansicht für JSON und YAML – mit:</p>
<ul>
<li>Syntax-Highlighting,</li>
<li>Falten und Aufklappen von Strukturen,</li>
<li>komfortabler Navigation und Suche.</li>
</ul>
<p>Beispiel:</p>
<div class="hll"><pre><span></span>kubectl<span class="w"> </span>get<span class="w"> </span>pods<span class="w"> </span>-oyaml<span class="w"> </span><span class="p">|</span><span class="w"> </span>yless
</pre></div>
<p>Das schöne: Man kann hier auf der Shell wunderbar uninteressante textblöcke einklappen um schnell die wichtigen Informationen zu fokussieren, und dann über Tastaturkommandos werte, oder jq/yq filter auf das aktuell ausgewählte Element kopieren, um das z.B. dann auf alle Pods in einem Namespace anzuwenden.</p>
<hr>
<h2>Fazit</h2>
<p>Mit diesen Tools – <code>jq</code>, <code>jo</code>, <code>yq</code>, <code>jless</code> und <code>yless</code> – wird das Arbeiten mit JSON und YAML auf der Shell <em>deutlich</em> angenehmer. Sehr gut investierte Zeit diese Werkzeuge (eines nach dem Anderen) zu lernen.</p>

    </section>
    
      <footer>
        <a href="../blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/">weiterlesen…</a>
      </footer>
    
  </article>

  
  
  <a href="../blog/">Weitere Beiträge…</a>

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2025 <a href="work/">Martin Häcker</a></span>
  </li>
  
    
    <li class="nav-item imprint">
      <a class="nav-link" href="meta/#imprint">
        Imprint
      </a></li>
  
    
    <li class="nav-item privacy-policy">
      <a class="nav-link" href="meta/#privacy-policy">
        Privacy Policy
      </a></li>
  
    
    <li class="nav-item colophon">
      <a class="nav-link" href="meta/#colophon">
        Colophon
      </a></li>
  
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="../blog/feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    <a class="nav-link" 
      rel="license" 
      target="_blank" 
      href="https://creativecommons.org/licenses/by-sa/4.0/deed"
    >
      <img 
        src="/static/cc-by-sa-88x31.png"
        alt="Creative Commons Attribution - Share Alike 4.0 International Lizense"
      >
    </a>
  </li>
</ul>
    </footer>
  </body>
</html>
