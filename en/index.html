
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="../static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/pygments.css">
    <title>üè†</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin H√§ckers Blog Artikel" href="../blog/feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="./" class="navbar-brand active">üè†<span class="sr-only">(ausgew√§hlt)</span></a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="blog/" class="nav-link">Blog</a></li>
    
      <li class="nav-item "><a href="categories/" class="nav-link">Categories</a></li>
    
      <li class="nav-item "><a href="projects/" class="nav-link">Projects</a></li>
    
      <li class="nav-item "><a href="publications/" class="nav-link">Ver√∂ffentlichungen</a></li>
    
      <li class="nav-item "><a href="about/" class="nav-link">About Me</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="../">üá©üá™</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="./">üá¨üáß</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

<a class="breadcrumb-item active" href="./">üè†</a>

</nav>
    </header>
    <article class="page  homepage container-fluid">
      
  <h1><a href="../about">Martin H√§cker's</a> Blog</h1>
<p>Welcome!</p>
<p>Here I deal with  <a href="../categories/code/">Software</a>, <a href="../categories/liquid/">Liquid Democracy</a>, <a href="../categories/go/">Go / Baduk / Weiqi</a>, <a href="../categories/cucina/">Cooking</a> and <a href="../categories/">everything else that interests me</a>. Look around, <a href="../projects/">use my software</a> and <a href="../blog/feed.xml">subscribe to my feed</a>!</p>
<p>Most of my blog will be in german - you will have to use a translating browser if you don't speak german. Most of the rest of my page should also be available in english.</p>

  
  <h1 name="first-blogpost">Neueste Eintr√§ge:</h1>
  
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2021/2/dependable-api-evolution/">
        Dependable API Evolution
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2021-02-18">Thursday, February 18, 2021</time>
      </p>
    </header>
    
    <section class="blog-post-body">
      <p>This is an old text that I just found on my hard disk. It's too good not to publish I think, as pretty much everything in it is still completely relevant. So here goes - a shout to the past, as this was written ca. 2014. At the time I discovered Semantic Versioning - and was discontent, because it is simply not enough. We as a community need a better name for what we want to do with APIs - just Semantic Versioning is not enough to reliably move forward and stay sane.</p>
<h2>My Suggestion: Define Dependable API Evolution</h2>
<p>The problem that prompted me to write this: I am sick and tired of APIs that do not evolve and that have old warts that are not fixed. At the same time I hate APIs that make every update to multi hour 'joy-ride' of debugging and finding out why the heck my system doesn't work anymore.</p>
<p>For this I think that <a href="https://semver.org">Semantic Versioning</a> is just not enough.</p>
<p>As an API provider you should adopt a dependable API evolution strategy that gives your users timely updates and new functionality, makes updating to a your newest version a breeze and joy because of new features instead of a reason for despair because of the amount of work it requires.</p>
<p>As an API user you should demand this so that you can send you patches and actually hope that they will get into the next version in a timely manner while it is not a burden to update to new revisions. And then there is the small part of actually enjoying an API that works and is extended in a good and healthy way.</p>
<p>Consider libraries like jQuery or Apples Cocoa where it is pretty much a no brainer to update to the newest version immediately. At the same time, they stay current and adapt and absorb new emerging patterns in a timely manner while fixing old warts and making the framework more and more consistent all the time. (Ok, some warts are not fixeable, but they try very hard)</p>
<p>I think it is Common Sense to do <strong>Dependable API Evolution</strong>, but for some reason it hasn't yet caught on as common knowledge - and there is no easy way to refer anyone to a document that explains it. So here I go.</p>
<h2>Problems</h2>
<ul>
<li>API's suddenly change names / types / behaviour from version to version</li>
<li>API's are suddenly removed from version to version without a warning period</li>
<li>Bugs/ Inconsistencies in APIs are not fixed</li>
<li>New and improved patterns or API designs are not adapted in a timely matter</li>
</ul>
<p>Extremes to avoid:</p>
<ul>
<li><p>The <em>Python Standard Library Syndrome</em>: Your Library is so <em>stable</em> that a module has to be dead/ unmaintained for 3-5 years before you consider adding it to your library. Some symptoms: API changes rarely, your API has very inconsistent naming, and design pattern use varies widely across your API. Also many of the non core modules have alternatives in the wild that have a vastly more fluent / short / powerful / consistent / modern APIs. Consider the Python standard library. Almost no development happens in there, many of it's modules are 10 and more years old with only the most required bugfixes going in. Not even the standard naming convention of python is used consistently throughout it's API.</p>
</li>
<li><p>The <em>Python 3k Syndrome</em>: Your users stick with an old version of your API and are very reluctant to update. Symptoms: You are forced to release new versions of it instead focussing your engineering on the newest version. You add Interims Versions, i.e evolutions of the old API version to make it easier for your users to switch to the newest version. You release new versions of your new API that add in old features again to make it easier for your users to upgrade. Consider the introduction of Python 3.0. Nobody used it. Three major revisions where required (3.0, 3.1, 3.2) before the community is actually considering its adoption. (And now - 2021 -  some 12 years after this text was written, there is still a lot of software around that is on Python 2).</p>
</li>
<li><p>The <em>Thousands of Patches Flying in Close Formation Syndrome</em>: Different parts of the API have very different fluency to it and don't match very well. Symptoms: Knowing one part of the API doesn't make it any easier to guess the names and workings of other parts of your API. Documentation cannot be consolidated by talking about the Design Patterns adopted by your framework, but instead is separated from each other and also very needed because you need to look at it for every module anew.</p>
</li>
<li><p>The <em>DOM API Syndrome</em>: Different implementations / versions of your API are so inconsistent, that it is almost impossible for users to consume all of them. Symptoms: There are adapter packages around to wrap your API and make it easier for users to actually use them and allow them to target different versions of that API that are in use in the wild. Consider the success of jQuery that does nothing that hiding the DOM-APIs behind something sane and manageable. (2021 me here - the web has started to tackle this problem, but boy, is this still a nightmare. Just the fact that projects like <a href="https://caniuse.com">can I use</a> are so much needed‚Ä¶)</p>
</li>
<li><p>The <em>Ruby Debugger Syndrome</em>: Different versions of your API change so much that consumers are unable to evolve an API that builds on it. Symptoms: Different versions of your API have different incompatible packages that implement the same functionality in an incompatible way. Backwards compatibility is virtually impossible. Consider the different Ruby-Debugger gems that have sprung up for the various versions of the interpreter. 'ruby-debug' for Ruby 1.8, 'ruby-debugger19' and later 'debugger' for Ruby 1.9, 'byebug' for Ruby 2.0 and it seems Ruby 2.1, already needs another different debugger package. Maybe it is 'pry' now...</p>
</li>
<li><p>The <em>Version 2 Rewrite Syndrome</em>: Symptoms: You have a branch in your repository that contains your next version, because it's so much different that you really need to retain a branch of the current version to apply bugfixes while you finish up the next version. Again, Python 2 and 3 comes to mind as an abhorrent example of this problem. 12 years after the release of Python 3.0 the, old version 2 branch was still around and kind of alive as small features where added, bugs fixed. Thats a problem - not a great achievement.</p>
</li>
</ul>
<h2>Solutions</h2>
<ul>
<li>Have a clear deprecation cycle and use it. It should stretch over multiple versions, and depending on the size or importance of that Deprecated API, this could be several major versions.</li>
<li><p>Your deprecation cycle should contain these steps (which could itself be a multi version rollout)</p>
<ul>
<li>Deprecated APIs are clearly marked in the documentation and source.</li>
<li>There is a clear statement in the source or documentation what the expected alternative is. What is the the developer expected to do / use instead?</li>
<li>Using a deprecated API should emit a warning.</li>
<li>Deprecated API is removed from the documentation. Still using it raises a warning.</li>
<li>Switch that warning to an error for developers, while only warning users.</li>
<li>Then and only then it should disappear. </li>
</ul>
<p>This is the single most important thing to do, everything else follows from this.</p>
</li>
<li>Don't just change / remove API. You released it? It's out there. Deprecate it but retain it for a time and then remove it! Document what users are expected to do instead. This documentation should be referred to / included in the warning that is raised when that API is used.</li>
<li>Document warts that you cannot fix anymore because they are too engrained in the API and are too widely adopted. It is important that your users understand that this is a wart and nothing to use as an example for others or patches that they send you. This ensures that your errors of the past are not repeated.</li>
<li>Never miss an opportunity to change your API to make it more uniform and or adopt a deeper pattern across it.</li>
<li>Focus a major part of your documentation on the patterns that underly your API and then don't repeat yourself in every part of the documentation but just refer to it.</li>
</ul>
<p>Do this and your API becomes more and more coherent over time. Users of such an API can often just use  a broad lisit of your API packages / objects / methods that are easy to scan / search. With that they can get an overview of what is available at a glance. They will often not need detailed documentation as they can just guess how stuff works, what stuff is named, how error handling works, ‚Ä¶ All of that makes for coding that is enjoyable and code just flows out of your fingers.</p>
<p>Also, users will update in a heartbeat allowing you to actually focus on newer versions, instead of having to maintain long term stable old versions and waste developer time on this rather non productive stuff.</p>
<p>What do you think? Should I set up a webpage like  <a href="http://semver.org">semver.org</a>? Do we need stickers like <img src="https://img.shields.io/badge/Dependable%20API%20Evolution-1.0-success" alt="Dependable API Evolution">?</p>
<p>Feedback welcome.</p>

    </section>
    
      <footer>
        <a href="../blog/2021/2/dependable-api-evolution/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2018/7/yeehaw-endlich-wieder-ein-blog/">
        Yeehaw! Endlich wieder ein Blog!
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2018-07-16">Monday, July 16, 2018</time>
      </p>
    </header>
    
    <section class="blog-post-body">
      <p>Lange hat es gedauert - Ahem.</p>
<p>In den letzten Monaten habe ich mich mit <a href="https://getlektor.com">Lektor</a> auseinandergesetzt. Mit ein Paar Plugins (<a href="https://github.com/humrochagf/lektor-creative-commons">CreativeCommons</a> und <a href="https://github.com/lektor/lektor-markdown-highlighter">Markdown Highlighter</a>) kann man viel Spa√ü beim Blog-Post schreiben haben.</p>
<p>Der gro√üe Vorteil von Lektor ist, dass man eine komplett statische Seite damit rendert. Man kann die Seite danach also √ºber ein CDN ausliefern - 'Internet Scale' ist also gar kein Problem‚Ä¶</p>
<p>Solche Systeme gibt es nat√ºrlich viele - aber mit Lektor kriegt man zus√§tzlich noch ein CMS (das Lokal l√§uft) - oder auch hinter <code>.htaccess</code> gesch√ºtzt laufen kann, so dass man keine Sorgen haben muss, dass einem √ºber so eine Webseite der Server aufgemacht wird.</p>
<p>Aber Lektor √ºberzeugt auch mit einer moderat einfachen <a href="https://www.getlektor.com/docs/api/">API</a>, selbst plugins daf√ºr zu schreiben ist einfach und macht Spa√ü. Fast wie es bei <a href="https://trac.edgewall.org">Track</a> ganz am Anfang auch einmal war. ‚ò∫Ô∏è</p>
<p>Ich freue mich dar√ºber dass ich jetzt eine voll-responsive Seite haben, die mit HTML und CSS wirklich auskommt - no JS needed. (Ich werde aber vielleicht in der Zukunft f√ºr Experimente auch JS in der Seite verwenden). F√ºr jetzt ist es erst mal das Experiment wie lange ich ohne JS auskomme.</p>
<p>Da w√§re zum Beispiel das Men√º - das auf Mobil mit Animation sch√∂n aufklappt. Hierzu habe ich verschiedene Techniken kombiniert.</p>
<ol>
<li><p>Die Verh√§ltnisse der ganzen Abmessungen werden √ºber <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS-Variablen</a> und <a href="https://developer.mozilla.org/de/docs/Web/CSS/calc">CSS-Calc</a> einmal global gesetzt. Das geht zwar noch nicht vollst√§ndig, da man CSS Variablen <a href="https://stackoverflow.com/questions/40722882/css-native-variables-not-working-in-media-queries#40723269">nicht in Media Queries einsetzen kann</a>, aber immerhin. Einzig dass man Stylesheets noch nicht 'nested' aufschreiben kann st√∂rt.</p>
</li>
<li><p>Die Animation beim klick auf das <a href="https://de.wikipedia.org/wiki/Hamburger-Men√º-Icon">Hamburger Men√º</a> sowie das √ñffnen des Men√ºs kommt komplett ohne JS aus. Damit das geht braucht es ein DOM Element, dass den State 'ein oder ausgeblendet' h√§lt, gleichzeitig via CSS abgefragt werden kann sowie diesen State durch Klick auf ein anderes Element √§ndert. Well, daf√ºr funktioniert lustiger Weise das <code>&lt;input type=checkbox id=menu-state&gt;</code> Element. Das wechselt den <code>checked</code>-Zustand, was mann dankenswerter Weise in CSS mittels <code>:checked</code> herausfinden kann. Der Clou ist aber, dass man irgendwo anders im Dokument ein <code>&lt;label for=menu-state&gt;</code> haben kann, auf das man Klicken kann um diesen State zu wechseln. Und <code>&lt;label&gt;</code> kann man im Gegensatz zu <code>&lt;input type=checkbox&gt;</code> in allen Browsern vern√ºnftig stylen. Und man kann mittels <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations">CSS-Animationen</a> alles animieren. Fuck yeah!</p>
</li>
</ol>

    </section>
    
      <footer>
        <a href="../blog/2018/7/yeehaw-endlich-wieder-ein-blog/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="../blog/2015/2/lockless-algorithms/">
        Lockless Algorithms
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2015-02-14">Saturday, February 14, 2015</time>
      </p>
    </header>
    
    <section class="blog-post-body">
      <p>Schon lange habe ich keine so passende Visualisierung mehr f√ºr etwas gesehen:</p>
<p><a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">Lockless Algorithms / Schlosslose Algorithmen</a>:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ufK2XRGUjuc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><a href="http://devopsreactions.tumblr.com/post/110529123748/lockess-algorithm">via devopsreactions</a></p>

    </section>
    
      <footer>
        <a href="../blog/2015/2/lockless-algorithms/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
  
  <a href="../blog/">Weitere Beitr√§ge‚Ä¶</a>

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2021 Martin H√§cker</span>
  </li>
  <li class="nav-item imprint"><a class="nav-link" href="about/#imprint">Impressum</a></li>
  <li class="nav-item privacy-policy"><a class="nav-link" href="about/#privacy-policy">Datenschutzerkl√§rung</a></li>
  <li class="nav-item colophon"><a class="nav-link" href="about/#colophon">Kolophon</a></li>
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="../blog/feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    
      <a class="nav-link" rel="license" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.de">
        <img alt="Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 Internationale Lizenz" style="border-width:0" src="/static/lektor-creative-commons/by-sa/4.0/88x31.png" />
      </a>
    
  </li>
</ul>
    </footer>
  </body>
</html>
