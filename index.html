
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="static/style.css">
    <link rel="stylesheet" href="static/pygments.css">
    <title>üè†</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin H√§ckers Blog Artikel" href="blog/feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="./" class="navbar-brand active">üè†<span class="sr-only">(ausgew√§hlt)</span></a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="work/" class="nav-link">Professionelle Softwareentwicklung</a></li>
    
      <li class="nav-item "><a href="projects/" class="nav-link">Projekte</a></li>
    
      <li class="nav-item "><a href="publications/" class="nav-link">Ver√∂ffentlichungen und Vortr√§ge</a></li>
    
      <li class="nav-item "><a href="blog/" class="nav-link">Blog</a></li>
    
      <li class="nav-item "><a href="categories/" class="nav-link">Kategorien</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="./">üá©üá™</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="en/">üá¨üáß</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

<a class="breadcrumb-item active" href="./">üè†</a>

</nav>
    </header>
    <article class="page  homepage container-fluid">
      
  <h1>Wilkommen!</h1>
<p>Ich bin <a href="work">Martin H√§cker</a>, ein Softwareentwickler mit mehr als 20 Jahren Erfahrung. Ich kann bei <a href="work">allen Aspekten der professionellen Softwareentwicklung</a> unterst√ºtzen.</p>
<p>In meinem Blog geht es um <a href="categories/code/">Software</a>, <a href="categories/liquid/">Liquid Democracy</a>, <a href="categories/go/">Go / Baduk / Weiqi</a>, <a href="categories/cucina/">Kochen</a>, <a href="http://gropies.de/">Chor-Singen</a>, <a href="https://de.wikipedia.org/wiki/Bouldern">Bouldern</a>, <a href="https://de.wikipedia.org/wiki/Billard">Billiard</a>, <a href="https://de.wikipedia.org/wiki/Gleitschirmfliegen">Gleitschirmfliegen</a>, <a href="https://de.wikipedia.org/wiki/Kategorie:Drachensport">Kiten</a>, <a href="https://de.wikipedia.org/wiki/Jonglieren">Jonglieren</a> und <a href="categories/">eben alles was mich interessiert</a>. Schau dich um, <a href="projects/">benutze meinen Code</a> und <a href="blog/feed.xml">abonniere meinen Feed</a>, um mein Blog bequem in einem Reader zu lesen.</p>
<p>W√§hrend meine Webseite zweisprachig ist, sind meine Blog-Posts in der Regel einsprachig deutsch oder englisch.</p>
<h1>Neueste Eintr√§ge:</h1>

  
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/">
        Textbearbeitung auf der Shell: grep, cut, awk, sed und tr
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2025-09-25">Donnerstag, 25. September 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/tr-in-action.png" alt="`tr` in aktion"></p>
<p>Diese f√ºnf kleinen Tools sind echte Arbeitspferde f√ºr jeden, der mit Text auf der Kommandozeile arbeitet. Sie haben viele Optionen ‚Äì aber man braucht nicht alles zu kennen. Schon mit ein paar Grundbefehlen kann man 80‚ÄØ% der typischen Aufgaben l√∂sen.</p>
<h3>1. <code>grep</code> ‚Äì Zeilen finden</h3>
<p>grep filtert Textzeilen anhand von Mustern. Praktisch, wenn man in langen Outputs schnell das Relevante sehen will.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Textzeilen ausgeben, die ein Wort enthalten</td>
<td><code>grep PATTERN</code></td>
<td>`cat protokoll.txt</td>
<td>grep "Fehler"`</td>
</tr>
<tr>
<td>Zeilen ausschlie√üen</td>
<td><code>grep -v PATTERN</code></td>
<td><code>grep -v "^#" protokoll.txt</code></td>
</tr>
<tr>
<td>In einem ganzen Projektbaum nach</td>
<td><code>grep -r PATTERN DIR</code></td>
<td><code>grep -r "TODO" src/</code></td>
</tr>
</tbody>
</table>
<p><strong>Tipps</strong></p>
<ul>
<li><code>-i</code> ignoriert Gro√ü/Kleinschreibung</li>
<li><code>-e</code> aktiviert Regul√§re Ausdr√ºcke (unter linux gibt es noch <code>-P</code> f√ºr Perl-kompatible Regex)</li>
</ul>
<p>Kombinationen √ºber Pipes machen grep besonders stark:</p>
<div class="hll"><pre><span></span>grep<span class="w"> </span>-r<span class="w"> </span>-P<span class="w"> </span><span class="s2">&quot;def \w*\(&quot;</span><span class="w"> </span>.<span class="w"> </span>--after-context<span class="w"> </span><span class="m">30</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-v<span class="w"> </span><span class="s2">&quot;bar&quot;</span>
</pre></div>
<p>F√ºr gro√üe Projekte lohnt sich ripgrep (rg), weil es schneller ist, <code>.gitignore</code> respektiert und regul√§re Ausdr√ºcke standardm√§√üig aktiviert.</p>
<h3>2. <code>cut</code> ‚Äì Spalten und Zeichen</h3>
<p><code>cut</code> schneidet Spalten oder Zeichen aus Textzeilen heraus. Funktioniert am besten, wenn der Trenner ein einzelnes Zeichen ist.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spalte 2 eine CSV <sup class="footnote-ref" id="fnref-csv"><a href="#fn-csv">1</a></sup></td>
<td><code>-d ',' -f 2</code></td>
<td><code>cut -d ',' -f 2 daten.csv</code></td>
</tr>
<tr>
<td>Zeichen 5‚Äë10 einer Zeile</td>
<td><code>-c 5-10</code></td>
<td><code>cut -c 5-10 string.txt</code></td>
</tr>
<tr>
<td>Mehrere Felder</td>
<td><code>-f 1,3,5</code></td>
<td><code>cut -d ';' -f 1,3,5 daten.txt</code></td>
</tr>
</tbody>
</table>
<p>Bei Whitespace-getrennten Daten st√∂√üt cut an Grenzen ‚Äì da ist <code>awk</code> besser.</p>
<h3>3. <code>awk</code> ‚Äì Felder und Muster</h3>
<p><code>awk</code> versteht Texte als Felder, getrennt durch Whitespace oder ein angegebenes Zeichen. Wenn man m√∂chte, kann man mit <code>awk</code> Text-Dateien fast wie Datenbanken abfragen, aber f√ºr den Anfang:</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spalten ausgeben</td>
<td><code>{print $1, $3}</code></td>
<td><code>awk '{print $1, $3}' daten.txt</code></td>
</tr>
<tr>
<td>Letzte Spalte ausgeben</td>
<td><code>{print $NF}</code></td>
<td><code>awk '{print $NF}' daten.txt</code></td>
</tr>
<tr>
<td>Summe einer Spalte</td>
<td><code>{s+=$2} END {print s}</code></td>
<td><code>awk '{s+=$2} END {print s}' zahlen.txt</code></td>
</tr>
</tbody>
</table>
<p><strong>N√ºtzliche Variablen</strong></p>
<ul>
<li><code>NF</code> = Anzahl Felder in der Zeile</li>
<li><code>NR</code> = aktuelle Zeilennummer</li>
</ul>
<h3>4. <code>sed</code> ‚Äì Suchen und Ersetzen</h3>
<p><code>sed</code> ist ein Stream-Editor: ideal f√ºr Ersetzungen und einfache Transformationen.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ersetzen</td>
<td><code>s/alt/neu/g</code></td>
<td><code>sed 's/Fehler/Warning/g' log.txt</code></td>
</tr>
</tbody>
</table>
<p>Vorsicht: Nie direkt in die gleiche Datei schreiben mit &gt; ‚Äì sonst √ºberschreibst du sie, bevor sie gelesen wurde. <strong>DAMIT HABE ICH SCHON DATEN VERLOREN</strong> Stattdessen:</p>
<div class="hll"><pre><span></span>sed<span class="w"> </span>-i<span class="w"> </span><span class="s1">&#39;s/alt/neu/g&#39;</span><span class="w"> </span>datei.txt<span class="w">   </span><span class="c1"># Direkt in der Datei √§ndern</span>
</pre></div>
<h3>5. <code>tr</code> ‚Äì Zeichen √ºbersetzen</h3>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gro√ü‚ÜíKlein</td>
<td><code>tr [:upper:][:lower:]</code></td>
<td><code>tr '[:upper:]' '[:lower:]' &lt; input.txt</code></td>
</tr>
<tr>
<td>Leerzeichen l√∂schen</td>
<td><code>tr -d ' '</code></td>
<td><code>tr -d ' ' &lt; file</code></td>
</tr>
<tr>
<td>ROT13 (Caesar‚ÄëShift)</td>
<td><code>tr 'a-z' 'n-za-m'</code></td>
<td><code>tr 'a-z' 'n-za-m' &lt; text.txt</code></td>
</tr>
<tr>
<td>Mehrere Zeichen gleichzeitig</td>
<td><code>tr 'abc' 'ABC'</code></td>
<td><code>tr 'abc' 'ABC' &lt; input.txt</code></td>
</tr>
</tbody>
</table>
<p>Beispiel: <code>$PATH</code> lesbarer machen:</p>
<div class="hll"><pre><span></span>‚ùØ<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$PATH</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>nl
</pre></div>
<h2>Fazit</h2>
<ul>
<li><strong><code>grep</code></strong>: Zeilen nach Mustern filtern</li>
<li><strong><code>cut</code></strong>: Spalten oder Zeichen ausschneiden.</li>
<li><strong><code>awk</code></strong>: Felder flexibel verarbeiten und berechnen.</li>
<li><strong><code>sed</code></strong>: Ersetzen und transformieren</li>
<li><strong><code>tr</code></strong>: Zeichen umwandeln oder l√∂schen</li>
</ul>
<p>üëâ Zusammengeschaltet mit Pipes (<code>|</code>) werden diese Tools zu einem Schweizer Taschenmesser f√ºr Textbearbeitung ‚Äì schnell, skriptbar und √ºberall verf√ºgbar.</p>
<div class="footnotes">
<hr>
<ol><li id="fn-csv"><p>CSV = Comma-Separated Values, kann nat√ºrlich auch maskierte Kommas in dem Wert enthalten, was dieser Befehl geflissentlich ignoriert oder falsch macht. Verwendet zum CSV-Parsen also bitte nicht diesen Shell-Befehl. Dieser Befehle sind daf√ºr da, auf der Shell schnell mal in eine Datei hineinzuschauen. Wenn das Ergebnis gut genug ist, kann man es auch weiter verarbeiten.<a href="#fnref-csv" class="footnote">&#8617;</a></p></li>
</ol>
</div>

    </section>
    
      <footer>
        <a href="blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/">
        Arbeiten mit JSON &amp; YAML auf der Shell
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2025-08-25">Montag, 25. August 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/yless.png" alt="yaml ganz angenem auf der Shell"></p>
<p>Arbeiten mit strukturierten Datenformaten auf der Shell kann anstrengend sein ‚Äì <strong>wenn man noch nicht die richtigen Tools daf√ºr hat</strong>.
Ob JSON aus einer API, YAML aus Kubernetes-Manifests oder riesige Logfiles ‚Äì ohne passende Helferlein endet man schnell bei un√ºbersichtlichem <code>grep</code>, <code>less</code> und Copy&amp;Paste.</p>
<p>Zum Gl√ºck gibt es eine Reihe von Werkzeugen, die genau daf√ºr gemacht sind:</p>
<ul>
<li><strong>jq</strong> ‚Äì JSON lesen, filtern und transformieren ‚Äì <a href="https://jqlang.org">https://jqlang.org</a></li>
<li><strong>jo</strong> ‚Äì JSON in der Shell erzeugen ‚Äì <a href="https://github.com/jpmens/jo">https://github.com/jpmens/jo</a></li>
<li><strong>yq</strong> ‚Äì YAML lesen, bearbeiten und konvertieren ‚Äì <a href="https://mikefarah.gitbook.io/yq/">https://mikefarah.gitbook.io/yq/</a></li>
<li><strong>jless / yless</strong> ‚Äì interaktiv in JSON/YAML navigieren ‚Äì <a href="https://jless.io">https://jless.io</a></li>
</ul>
<p>In diesem Beitrag stelle ich euch diese Tools vor ‚Äì mit Beispielen, die ihr direkt in eurer eigenen Shell ausprobieren k√∂nnt.</p>
<hr>
<h2>jq ‚Äì der Klassiker f√ºr JSON</h2>
<p>Das vermutlich bekannteste und am weitesten verbreitete Tool f√ºr JSON ist <a href="https://jqlang.org"><strong><code>jq</code></strong></a>.
Es ist so etwas wie der <em>Schweizer Taschenmesser</em> f√ºr JSON:</p>
<ul>
<li>formatiert unlesbare Minified-JSON-Dateien,</li>
<li>extrahiert gezielt Werte,</li>
<li>filtert und transformiert Daten,</li>
<li>eignet sich f√ºr einmalige Ad-hoc-Analysen genauso wie f√ºr Skripte.</li>
</ul>
<p>Ein einfaches Beispiel: JSON sch√∂n formatieren:</p>
<pre><code>$ cat data.json
{"user":{"id":42,"name":"Alice"},"active":true}
$ cat data.json | jq # oder `jq &lt; data.json`
</code></pre>
<div class="hll"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;user&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;active&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>So schnell wird aus einem un√ºbersichtlichen Einzeiler eine lesbare Struktur.</p>
<p>Mann kann es aber auch super in scripten verwenden um Daten aus json zu extrahieren:</p>
<div class="hll"><pre><span></span>get_current_gitlab_token<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>kubectl<span class="w"> </span>get<span class="w"> </span>secret<span class="w"> </span><span class="nv">$SECRETNAME</span><span class="w"> </span>-n<span class="w"> </span><span class="nv">$INITIALNAMESPACE</span><span class="w"> </span>-o<span class="w"> </span>json<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>jq<span class="w"> </span>-r<span class="w"> </span><span class="s1">&#39;.data[&quot;.dockerconfigjson&quot;]&#39;</span><span class="w"> </span><span class="m">2</span>&gt;/dev/null<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>base64<span class="w"> </span>--decode<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>jq<span class="w"> </span>-r<span class="w"> </span><span class="s1">&#39;.auths[&quot;registry.gitlab.com&quot;].password&#39;</span><span class="w"> </span><span class="m">2</span>&gt;/dev/null
<span class="o">}</span>
</pre></div>
<p>Oder um in einem JSON-File Daten einzutragen:</p>
<div class="hll"><pre><span></span>kubectl<span class="w"> </span>get<span class="w"> </span>secrets<span class="w"> </span>shipa-certificates<span class="w"> </span>-o<span class="w"> </span>json<span class="w"> </span><span class="se">\</span>
<span class="w">        </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="s2">&quot;.data[\&quot;ca.pem\&quot;] |= \&quot;</span><span class="nv">$CA_CERT</span><span class="s2">\&quot;&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">        </span><span class="p">|</span><span class="w"> </span>kubectl<span class="w"> </span>apply<span class="w"> </span>-f<span class="w"> </span>-
</pre></div>
<p><code>jq</code> kann noch viel mehr. Wer das Werkzeug noch nicht kennt sollte unbedingt ein paar Minuten investieren um <a href="https://jqlang.org/tutorial/">das Tutorial</a> querzulesen, und dann bei der n√§chsten Einsatzm√∂glichkeit gezielt nach der Syntax schauen. Pro tip: KI's k√∂nnen diese Syntax prima, und <code>jless</code> (kommt gleich) kann diese auch generieren.</p>
<hr>
<h2>jo ‚Äì JSON in der Shell erzeugen</h2>
<p>W√§hrend <code>jq</code> ideal zum Lesen und Transformieren ist, eignet sich <strong><code>jo</code></strong> perfekt, um JSON direkt in der Shell zu erstellen. Damit lassen sich Testdaten oder API-Payloads schnell zusammenbauen.</p>
<p>Ein einfaches Beispiel:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span><span class="nv">name</span><span class="o">=</span>Alice<span class="w"> </span><span class="nv">age</span><span class="o">=</span><span class="m">30</span><span class="w"> </span><span class="nv">active</span><span class="o">=</span><span class="nb">true</span>
</pre></div>
<p>Ausgabe:</p>
<div class="hll"><pre><span></span><span class="p">{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="nt">&quot;age&quot;</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="nt">&quot;active&quot;</span><span class="p">:</span><span class="kc">true</span><span class="p">}</span>
</pre></div>
<p>Auch Arrays sind m√∂glich:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span>-a<span class="w"> </span>red<span class="w"> </span>green<span class="w"> </span>blue
</pre></div>
<p>‚ûú <code>["red","green","blue"]</code></p>
<p>Verschachtelte Objekte:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span><span class="nv">user</span><span class="o">=</span><span class="k">$(</span>jo<span class="w"> </span><span class="nv">name</span><span class="o">=</span>Alice<span class="w"> </span><span class="nv">id</span><span class="o">=</span><span class="m">42</span><span class="k">)</span><span class="w"> </span><span class="nv">project</span><span class="o">=</span>Demo
</pre></div>
<p>‚ûú <code>{"user":{"name":"Alice","id":42},"project":"Demo"}</code></p>
<p>Das eignet sich sehr gut f√ºr schnelle <code>curl</code>-Requests, aber insbesondere auch f√ºr shell scripte in denen inline json sonst sehr schnell sehr un√ºbersichtlich wird:</p>
<div class="hll"><pre><span></span>curl<span class="w"> </span>-X<span class="w"> </span>POST<span class="w"> </span>-H<span class="w"> </span><span class="s2">&quot;Content-Type: application/json&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">     </span>-d<span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>jo<span class="w"> </span><span class="nv">username</span><span class="o">=</span>dev<span class="w"> </span><span class="nv">password</span><span class="o">=</span>secret<span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">     </span>https://example.com/api/login
</pre></div>
<hr>
<h2>yq ‚Äì YAML lesen und bearbeiten</h2>
<p>YAML verwenden wir √ºberall, am meisten habe ich in Kubernetes damit zu tun. <a href="https://mikefarah.gitbook.io/yq/"><strong><code>yq</code></strong></a> ist das Werkzeug der Wahl, um YAML-Dateien zu lesen, zu durchsuchen und zu editieren. Die Syntax ist sehr nahe an <code>jq</code>, das Werkzeug kann neben YAML aber auch JSON, TOML und XML verarbeiten, und zwischen diesesn Konvertieren. Im wesentlichen kann es das gleiche wie <code>jq</code>, eben auch f√ºr YAML.</p>
<hr>
<h2>jless &amp; yless ‚Äì interaktiv st√∂bern</h2>
<p>Wenn Dateien zu gro√ü oder zu komplex werden, helfen <a href="https://jless.io"><strong><code>jless</code></strong></a> und <strong><code>yless</code></strong> (ein <code>alias yless=jless --yaml</code>. Sie bieten eine interaktive Ansicht f√ºr JSON und YAML ‚Äì mit:</p>
<ul>
<li>Syntax-Highlighting,</li>
<li>Falten und Aufklappen von Strukturen,</li>
<li>komfortabler Navigation und Suche.</li>
</ul>
<p>Beispiel:</p>
<div class="hll"><pre><span></span>kubectl<span class="w"> </span>get<span class="w"> </span>pods<span class="w"> </span>-oyaml<span class="w"> </span><span class="p">|</span><span class="w"> </span>yless
</pre></div>
<p>Das sch√∂ne: Man kann hier auf der Shell wunderbar uninteressante textbl√∂cke einklappen um schnell die wichtigen Informationen zu fokussieren, und dann √ºber Tastaturkommandos werte, oder jq/yq filter auf das aktuell ausgew√§hlte Element kopieren, um das z.B. dann auf alle Pods in einem Namespace anzuwenden.</p>
<hr>
<h2>Fazit</h2>
<p>Mit diesen Tools ‚Äì <code>jq</code>, <code>jo</code>, <code>yq</code>, <code>jless</code> und <code>yless</code> ‚Äì wird das Arbeiten mit JSON und YAML auf der Shell <em>deutlich</em> angenehmer. Sehr gut investierte Zeit diese Werkzeuge (eines nach dem Anderen) zu lernen.</p>

    </section>
    
      <footer>
        <a href="blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="blog/2025/8/mit-llm-rag-einfach-mal-ausprobieren-direkt-von-der-shell/">
        Mit llm RAG einfach mal ausprobieren ‚Äì direkt von der Shell
        </a>
      </h2>
      <p class="meta">
        written by Martin H√§cker on <time datetime="2025-08-07">Donnerstag, 7. August 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="blog/2025/8/mit-llm-rag-einfach-mal-ausprobieren-direkt-von-der-shell/workflow.png" alt="Ablaufdiagramm">
Einer der coolsten Aha-Momente der letzten Tage bei mir war, wie einfach und niederschweflig das Arbeiten mit Retrieval-Augmented Generation (RAG) von der Shell inzwischen sein kann ‚Äì ganz ohne spezielle Infrastruktur, Vektor-Datenbank oder Server-Backend. Das Python-Tool <a href="https://pypi.org/project/llm/"><code>llm</code></a> macht  das m√∂glich: RAG direkt aus der Kommandozeile, mit SQLite als Backend und einfachen Kommandos, die sich hervorragend in Shell-Workflows integrieren lassen.</p>
<h2>Ein Power Tool f√ºr Sprachmodelle in der Shell</h2>
<p><a href="https://llm.datasette.io/en/stable/"><code>llm</code> kann nat√ºrlich noch viel mehr und ist ein Power Tool, das den Einsatz von KI direkt im Terminal erlaubt</a>. Es erlaubt mit beliebigen API-Providern oder lokalen Modellen zu sprechen und integriert diese damit nahtlos in eigene Skripte. Use Cases: Daten hinein pipen und mit dem LLM bearbeiten. Ob zusammenfassen, erkl√§ren, √ºbersetzen, mit einem aufwendigen Prompt aus einer Datei beackern‚Ä¶ Da geht so viel. Egal was Ihr aus diesem Artikel mitnehmt, zumindest sollte es sein das Ihr <code>llm</code>¬†in euren Workflow aufnehmt und installiert.</p>
<h2>Der RAG-Workflow von der Shell aus</h2>
<p>Ein kompletter RAG-Workflow funktioniert mit <code>llm</code> in wenigen Schritten. <a href="https://building-with-llms-pycon-2025.readthedocs.io/en/latest/semantic-search-and-rag.html">Diese Demo hier hab ich von Simon Willison geklaut, dem Autor von <code>llm</code></a>. <a href="https://github.com/python/peps">Hier wird semantische Suche in den Python Enhancement Proposals demonstriert</a>. Dieses Tutorial verwendet einen lokalen LLM-Server, man kann das aber nat√ºrlich auch mit GitHub Copilot oder √§hnlichen Modellen machen. Herauszufinden wie die dort hei√üen und zu verbinden sind bleibt ein Exercise f√ºr den Leser.</p>
<h3>1. Dateien vorbereiten</h3>
<p>Wir erstellen gek√ºrzte Versionen von Textdateien:</p>
<div class="hll"><pre><span></span>mkdir<span class="w"> </span>-p<span class="w"> </span>peps-truncated
<span class="k">for</span><span class="w"> </span>f<span class="w"> </span><span class="k">in</span><span class="w"> </span>peps/*.rst<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span>head<span class="w"> </span>-c<span class="w"> </span><span class="m">8000</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$f</span><span class="s2">&quot;</span><span class="w"> </span>&gt;<span class="w"> </span><span class="s2">&quot;peps-truncated/</span><span class="k">$(</span>basename<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$f</span><span class="s2">&quot;</span><span class="k">)</span><span class="s2">&quot;</span>
<span class="k">done</span>
</pre></div>
<p>Das ist nat√ºrlich streng genommen falsch, weil wir ganz viel Daten wegschmei√üen. Einiges spricht aber trotzdem daf√ºr:</p>
<ol>
<li>Gerade lokale Modelle haben gerne nicht so gro√üe Kontext-Fenster und da muss das Dokument reinpassen.</li>
<li>Meistens steht am Anfang eines Dokuments worum es geht. F√ºr unsere Zwecke also eine gute N√§herung.</li>
</ol>
<p>Um das sp√§ter in ein Produkt umzuwandeln m√ºssten wir uns noch weitere Strategien¬†anschauen, z.B. mit einem Sliding Window √ºber die Dokumente zu gehen und f√ºr jeden Abschnitt ein Embedding zu erzeugen. Grunds√§tzlich ist es aber eine gute Idee verschiedene Indexe zu erzeugen die unterschiedliche Zwecke erf√ºllen.</p>
<h3>2. Vektor-Index erstellen</h3>
<div class="hll"><pre><span></span>llm<span class="w"> </span>embed-multi<span class="w"> </span>peps<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-m<span class="w"> </span>mxbai-embed-large<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--files<span class="w"> </span>peps-truncated<span class="w"> </span><span class="s1">&#39;pep-3*.rst&#39;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-d<span class="w"> </span>peps.db<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--store
</pre></div>
<p>Das erzeugt eine SQLite-Datenbank mit eingebetteten Vektoren. Wichtig: Die Datenbank speichert auch, mit welchem Modell die Einbettung erfolgte ‚Äì bei weiteren Operationen auf der gleichen Collection <code>peps</code> ignoriert <code>llm</code>¬†den Modell-Parameter ohne Fehlermeldung!</p>
<p>Seiten-Notiz: Embeddings, was ist das? Ein Embedding ist eine Umwandlung von einem Text in eine Zahlenreihe (Mathematisch: Einen Vektor). Jeder dieser Vektoren beschreibt eine Koordinate in einem Hoch-Dimensionalen Raum, mit der Eigenschaft, das Koordinaten die sich Nahe sind von einem Text kommen der semantisch √Ñhnlich ist. Darin kann man sogar Rechnen, ein etwas √ºberstrapaziertes Beispiel w√§re z.B. der Vektor f√ºr K√∂nig + Weiblich = K√∂nigin. <a href="https://simonwillison.net/2023/Oct/23/embeddings/">Mehr gibts hier</a></p>
<h3>3. Abfragen stellen</h3>
<div class="hll"><pre><span></span>llm<span class="w"> </span>similar<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;What do string templates look like?&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>-d<span class="w"> </span>peps.db<span class="w"> </span>-n<span class="w"> </span><span class="m">2</span><span class="w"> </span>peps<span class="w"> </span><span class="se">\</span>
<span class="w">  </span><span class="p">|</span><span class="w"> </span>llm<span class="w"> </span>-s<span class="w"> </span><span class="s2">&quot;Answer the question: What do string templates look like?&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-m<span class="w"> </span>devstral<span class="w"> </span>-o<span class="w"> </span>num_ctx<span class="w"> </span>256_00
</pre></div>
<p>Hier wird erst √§hnliche Inhalte zur Frage gesucht. Wichtige Details: Das Kontext-Fenster des Sprachmodells das antwortet muss gro√ü genug sein, das es alle Antworten in seinen Kontext aufnehmen kann. Ansonsten wird gerne der Anfang abgeschnitten - und da steht nat√ºrlich der Treffer mit dem besten Score.</p>
<h3>4. Automatisieren</h3>
<p>Wir k√∂nnen sogar direkt ein Skript generieren lassen:</p>
<div class="hll"><pre><span></span>llm<span class="w"> </span><span class="s1">&#39;</span>
<span class="s1">Build me a bash script like this:</span>
<span class="s1">./pep-qa.sh &quot;What do string templates look like?&quot;</span>
<span class="s1">It should first run:</span>
<span class="s1">llm similar -c $question -d peps.db peps</span>
<span class="s1">Then it should pipe the output from that to:</span>
<span class="s1">llm -s &quot;Answer the question: $question&quot; -m gpt-4.1-mini</span>
<span class="s1">That last command should run so the output is visible as it runs.</span>
<span class="s1">&#39;</span><span class="w"> </span>-x<span class="w"> </span>&gt;<span class="w"> </span>pep-qa.sh
</pre></div>
<h2>Fazit</h2>
<p>Was fr√ºher nach viel Setup aussah (Vektor-Datenbank, Backend-API, RAG-Pipeline), ist heute in wenigen Shell-Befehlen machbar. SQLite funktioniert dabei erstaunlich gut ‚Äì <code>llm</code> f√ºhrt einfach einen Full-Table-Scan durch und berechnet die Vektor-Abst√§nde direkt. Das ist nicht hyper-skalierbar, aber bis 10.000 bis 100.000 Eintr√§ge durchaus brauchbar.</p>
<p>Und das Beste: <code>llm</code> l√§sst sich √ºberall in bestehende Shell-Skripte und Workflows einbauen ‚Äì sogar mit piped Input. Wer also mal eben eine intelligente Suche oder ein Sprachmodell in seinen CLI-Workflow integrieren will, findet hier ein extrem m√§chtiges Toolset.</p>
<p>Ich kann nur empfehlen ein Shell-Werkzeug wie <code>llm</code>¬†zu lernen.</p>

    </section>
    
      <footer>
        <a href="blog/2025/8/mit-llm-rag-einfach-mal-ausprobieren-direkt-von-der-shell/">weiterlesen‚Ä¶</a>
      </footer>
    
  </article>

  
  
  <a href="blog/">Weitere Beitr√§ge‚Ä¶</a>

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2025 <a href="work/">Martin H√§cker</a></span>
  </li>
  
    
    <li class="nav-item imprint">
      <a class="nav-link" href="meta/#imprint">
        Impressum
      </a></li>
  
    
    <li class="nav-item privacy-policy">
      <a class="nav-link" href="meta/#privacy-policy">
        Datenschutzerkl√§rung
      </a></li>
  
    
    <li class="nav-item colophon">
      <a class="nav-link" href="meta/#colophon">
        Kolophon
      </a></li>
  
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="blog/feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    <a class="nav-link" 
      rel="license" 
      target="_blank" 
      href="https://creativecommons.org/licenses/by-sa/4.0/deed.de"
    >
      <img 
        src="/static/cc-by-sa-88x31.png"
        alt="Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 Internationale Lizenz"
      >
    </a>
  </li>
</ul>
    </footer>
  </body>
</html>
