
<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="static/bootstrap-4.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="static/style.css">
    <link rel="stylesheet" href="static/pygments.css">
    <title>🏠</title>
    <link rel="alternate" type="application/atom+xml" title="RSS: Martin Häckers Blog Artikel" href="blog/feed.xml" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-expand-sm">
  <a href="./" class="navbar-brand active">🏠<span class="sr-only">(ausgewählt)</span></a>
  <input type="checkbox" id="navbar-toggle-checkbox">
  <label for="navbar-toggle-checkbox" class="navbar-brand navbar-toggle d-sm-none float-right" aria-label="Navigation Umschalten">
    <span></span>
  </label>
  <ul class="navbar-nav collapse navbar-collapse">
    
      <li class="nav-item "><a href="work/" class="nav-link">Professionelle Softwareentwicklung</a></li>
    
      <li class="nav-item "><a href="projects/" class="nav-link">Projekte</a></li>
    
      <li class="nav-item "><a href="publications/" class="nav-link">Veröffentlichungen und Vorträge</a></li>
    
      <li class="nav-item "><a href="blog/" class="nav-link">Blog</a></li>
    
      <li class="nav-item "><a href="categories/" class="nav-link">Kategorien</a></li>
    
    <li class="nav-item ml-auto">
      <a class=nav-link href="./">🇩🇪</a>
    </li>
    <li class="nav-item pull-right">
      <a class=nav-link href="en/">🇬🇧</a>
    </li>
  </ul>
</nav>
<nav class="breadcrumb">
  

<a class="breadcrumb-item active" href="./">🏠</a>

</nav>
    </header>
    <article class="page  homepage container-fluid">
      
  <h1>Wilkommen!</h1>
<p>Ich bin <a href="work">Martin Häcker</a>, ein Softwareentwickler mit mehr als 20 Jahren Erfahrung. Ich kann bei <a href="work">allen Aspekten der professionellen Softwareentwicklung</a> unterstützen.</p>
<p>In meinem Blog geht es um <a href="categories/code/">Software</a>, <a href="categories/liquid/">Liquid Democracy</a>, <a href="categories/go/">Go / Baduk / Weiqi</a>, <a href="categories/cucina/">Kochen</a>, <a href="http://gropies.de/">Chor-Singen</a>, <a href="https://de.wikipedia.org/wiki/Bouldern">Bouldern</a>, <a href="https://de.wikipedia.org/wiki/Billard">Billiard</a>, <a href="https://de.wikipedia.org/wiki/Gleitschirmfliegen">Gleitschirmfliegen</a>, <a href="https://de.wikipedia.org/wiki/Kategorie:Drachensport">Kiten</a>, <a href="https://de.wikipedia.org/wiki/Jonglieren">Jonglieren</a> und <a href="categories/">eben alles was mich interessiert</a>. Schau dich um, <a href="projects/">benutze meinen Code</a> und <a href="blog/feed.xml">abonniere meinen Feed</a>, um mein Blog bequem in einem Reader zu lesen.</p>
<p>Während meine Webseite zweisprachig ist, sind meine Blog-Posts in der Regel einsprachig deutsch oder englisch.</p>
<h1>Neueste Einträge:</h1>

  
  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/">
        Textbearbeitung auf der Shell: grep, cut, awk, sed und tr
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-09-25">Donnerstag, 25. September 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/tr-in-action.png" alt="`tr` in aktion"></p>
<p>Diese fünf kleinen Tools sind echte Arbeitspferde für jeden, der mit Text auf der Kommandozeile arbeitet. Sie haben viele Optionen – aber man braucht nicht alles zu kennen. Schon mit ein paar Grundbefehlen kann man 80 % der typischen Aufgaben lösen.</p>
<h3>1. <code>grep</code> – Zeilen finden</h3>
<p>grep filtert Textzeilen anhand von Mustern. Praktisch, wenn man in langen Outputs schnell das Relevante sehen will.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Textzeilen ausgeben, die ein Wort enthalten</td>
<td><code>grep PATTERN</code></td>
<td>`cat protokoll.txt</td>
<td>grep "Fehler"`</td>
</tr>
<tr>
<td>Zeilen ausschließen</td>
<td><code>grep -v PATTERN</code></td>
<td><code>grep -v "^#" protokoll.txt</code></td>
</tr>
<tr>
<td>In einem ganzen Projektbaum nach</td>
<td><code>grep -r PATTERN DIR</code></td>
<td><code>grep -r "TODO" src/</code></td>
</tr>
</tbody>
</table>
<p><strong>Tipps</strong></p>
<ul>
<li><code>-i</code> ignoriert Groß/Kleinschreibung</li>
<li><code>-e</code> aktiviert Reguläre Ausdrücke (unter linux gibt es noch <code>-P</code> für Perl-kompatible Regex)</li>
</ul>
<p>Kombinationen über Pipes machen grep besonders stark:</p>
<div class="hll"><pre><span></span>grep<span class="w"> </span>-r<span class="w"> </span>-P<span class="w"> </span><span class="s2">&quot;def \w*\(&quot;</span><span class="w"> </span>.<span class="w"> </span>--after-context<span class="w"> </span><span class="m">30</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-v<span class="w"> </span><span class="s2">&quot;bar&quot;</span>
</pre></div>
<p>Für große Projekte lohnt sich ripgrep (rg), weil es schneller ist, <code>.gitignore</code> respektiert und reguläre Ausdrücke standardmäßig aktiviert.</p>
<h3>2. <code>cut</code> – Spalten und Zeichen</h3>
<p><code>cut</code> schneidet Spalten oder Zeichen aus Textzeilen heraus. Funktioniert am besten, wenn der Trenner ein einzelnes Zeichen ist.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spalte 2 eine CSV <sup class="footnote-ref" id="fnref-csv"><a href="#fn-csv">1</a></sup></td>
<td><code>-d ',' -f 2</code></td>
<td><code>cut -d ',' -f 2 daten.csv</code></td>
</tr>
<tr>
<td>Zeichen 5‑10 einer Zeile</td>
<td><code>-c 5-10</code></td>
<td><code>cut -c 5-10 string.txt</code></td>
</tr>
<tr>
<td>Mehrere Felder</td>
<td><code>-f 1,3,5</code></td>
<td><code>cut -d ';' -f 1,3,5 daten.txt</code></td>
</tr>
</tbody>
</table>
<p>Bei Whitespace-getrennten Daten stößt cut an Grenzen – da ist <code>awk</code> besser.</p>
<h3>3. <code>awk</code> – Felder und Muster</h3>
<p><code>awk</code> versteht Texte als Felder, getrennt durch Whitespace oder ein angegebenes Zeichen. Wenn man möchte, kann man mit <code>awk</code> Text-Dateien fast wie Datenbanken abfragen, aber für den Anfang:</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spalten ausgeben</td>
<td><code>{print $1, $3}</code></td>
<td><code>awk '{print $1, $3}' daten.txt</code></td>
</tr>
<tr>
<td>Letzte Spalte ausgeben</td>
<td><code>{print $NF}</code></td>
<td><code>awk '{print $NF}' daten.txt</code></td>
</tr>
<tr>
<td>Summe einer Spalte</td>
<td><code>{s+=$2} END {print s}</code></td>
<td><code>awk '{s+=$2} END {print s}' zahlen.txt</code></td>
</tr>
</tbody>
</table>
<p><strong>Nützliche Variablen</strong></p>
<ul>
<li><code>NF</code> = Anzahl Felder in der Zeile</li>
<li><code>NR</code> = aktuelle Zeilennummer</li>
</ul>
<h3>4. <code>sed</code> – Suchen und Ersetzen</h3>
<p><code>sed</code> ist ein Stream-Editor: ideal für Ersetzungen und einfache Transformationen.</p>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ersetzen</td>
<td><code>s/alt/neu/g</code></td>
<td><code>sed 's/Fehler/Warning/g' log.txt</code></td>
</tr>
</tbody>
</table>
<p>Vorsicht: Nie direkt in die gleiche Datei schreiben mit &gt; – sonst überschreibst du sie, bevor sie gelesen wurde. <strong>DAMIT HABE ICH SCHON DATEN VERLOREN</strong> Stattdessen:</p>
<div class="hll"><pre><span></span>sed<span class="w"> </span>-i<span class="w"> </span><span class="s1">&#39;s/alt/neu/g&#39;</span><span class="w"> </span>datei.txt<span class="w">   </span><span class="c1"># Direkt in der Datei ändern</span>
</pre></div>
<h3>5. <code>tr</code> – Zeichen übersetzen</h3>
<table>
<thead><tr>
<th>Aufgabe</th>
<th>Befehl</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>Groß→Klein</td>
<td><code>tr [:upper:][:lower:]</code></td>
<td><code>tr '[:upper:]' '[:lower:]' &lt; input.txt</code></td>
</tr>
<tr>
<td>Leerzeichen löschen</td>
<td><code>tr -d ' '</code></td>
<td><code>tr -d ' ' &lt; file</code></td>
</tr>
<tr>
<td>ROT13 (Caesar‑Shift)</td>
<td><code>tr 'a-z' 'n-za-m'</code></td>
<td><code>tr 'a-z' 'n-za-m' &lt; text.txt</code></td>
</tr>
<tr>
<td>Mehrere Zeichen gleichzeitig</td>
<td><code>tr 'abc' 'ABC'</code></td>
<td><code>tr 'abc' 'ABC' &lt; input.txt</code></td>
</tr>
</tbody>
</table>
<p>Beispiel: <code>$PATH</code> lesbarer machen:</p>
<div class="hll"><pre><span></span>❯<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$PATH</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>nl
</pre></div>
<h2>Fazit</h2>
<ul>
<li><strong><code>grep</code></strong>: Zeilen nach Mustern filtern</li>
<li><strong><code>cut</code></strong>: Spalten oder Zeichen ausschneiden.</li>
<li><strong><code>awk</code></strong>: Felder flexibel verarbeiten und berechnen.</li>
<li><strong><code>sed</code></strong>: Ersetzen und transformieren</li>
<li><strong><code>tr</code></strong>: Zeichen umwandeln oder löschen</li>
</ul>
<p>👉 Zusammengeschaltet mit Pipes (<code>|</code>) werden diese Tools zu einem Schweizer Taschenmesser für Textbearbeitung – schnell, skriptbar und überall verfügbar.</p>
<div class="footnotes">
<hr>
<ol><li id="fn-csv"><p>CSV = Comma-Separated Values, kann natürlich auch maskierte Kommas in dem Wert enthalten, was dieser Befehl geflissentlich ignoriert oder falsch macht. Verwendet zum CSV-Parsen also bitte nicht diesen Shell-Befehl. Dieser Befehle sind dafür da, auf der Shell schnell mal in eine Datei hineinzuschauen. Wenn das Ergebnis gut genug ist, kann man es auch weiter verarbeiten.<a href="#fnref-csv" class="footnote">&#8617;</a></p></li>
</ol>
</div>

    </section>
    
      <footer>
        <a href="blog/2025/9/textbearbeitung-mit-grep-tr-cut-awk-und-sed/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/">
        Arbeiten mit JSON &amp; YAML auf der Shell
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-08-25">Montag, 25. August 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/yless.png" alt="yaml ganz angenem auf der Shell"></p>
<p>Arbeiten mit strukturierten Datenformaten auf der Shell kann anstrengend sein – <strong>wenn man noch nicht die richtigen Tools dafür hat</strong>.
Ob JSON aus einer API, YAML aus Kubernetes-Manifests oder riesige Logfiles – ohne passende Helferlein endet man schnell bei unübersichtlichem <code>grep</code>, <code>less</code> und Copy&amp;Paste.</p>
<p>Zum Glück gibt es eine Reihe von Werkzeugen, die genau dafür gemacht sind:</p>
<ul>
<li><strong>jq</strong> – JSON lesen, filtern und transformieren – <a href="https://jqlang.org">https://jqlang.org</a></li>
<li><strong>jo</strong> – JSON in der Shell erzeugen – <a href="https://github.com/jpmens/jo">https://github.com/jpmens/jo</a></li>
<li><strong>yq</strong> – YAML lesen, bearbeiten und konvertieren – <a href="https://mikefarah.gitbook.io/yq/">https://mikefarah.gitbook.io/yq/</a></li>
<li><strong>jless / yless</strong> – interaktiv in JSON/YAML navigieren – <a href="https://jless.io">https://jless.io</a></li>
</ul>
<p>In diesem Beitrag stelle ich euch diese Tools vor – mit Beispielen, die ihr direkt in eurer eigenen Shell ausprobieren könnt.</p>
<hr>
<h2>jq – der Klassiker für JSON</h2>
<p>Das vermutlich bekannteste und am weitesten verbreitete Tool für JSON ist <a href="https://jqlang.org"><strong><code>jq</code></strong></a>.
Es ist so etwas wie der <em>Schweizer Taschenmesser</em> für JSON:</p>
<ul>
<li>formatiert unlesbare Minified-JSON-Dateien,</li>
<li>extrahiert gezielt Werte,</li>
<li>filtert und transformiert Daten,</li>
<li>eignet sich für einmalige Ad-hoc-Analysen genauso wie für Skripte.</li>
</ul>
<p>Ein einfaches Beispiel: JSON schön formatieren:</p>
<pre><code>$ cat data.json
{"user":{"id":42,"name":"Alice"},"active":true}
$ cat data.json | jq # oder `jq &lt; data.json`
</code></pre>
<div class="hll"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;user&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;active&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>So schnell wird aus einem unübersichtlichen Einzeiler eine lesbare Struktur.</p>
<p>Mann kann es aber auch super in scripten verwenden um Daten aus json zu extrahieren:</p>
<div class="hll"><pre><span></span>get_current_gitlab_token<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>kubectl<span class="w"> </span>get<span class="w"> </span>secret<span class="w"> </span><span class="nv">$SECRETNAME</span><span class="w"> </span>-n<span class="w"> </span><span class="nv">$INITIALNAMESPACE</span><span class="w"> </span>-o<span class="w"> </span>json<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>jq<span class="w"> </span>-r<span class="w"> </span><span class="s1">&#39;.data[&quot;.dockerconfigjson&quot;]&#39;</span><span class="w"> </span><span class="m">2</span>&gt;/dev/null<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>base64<span class="w"> </span>--decode<span class="w"> </span><span class="p">|</span>
<span class="w">        </span>jq<span class="w"> </span>-r<span class="w"> </span><span class="s1">&#39;.auths[&quot;registry.gitlab.com&quot;].password&#39;</span><span class="w"> </span><span class="m">2</span>&gt;/dev/null
<span class="o">}</span>
</pre></div>
<p>Oder um in einem JSON-File Daten einzutragen:</p>
<div class="hll"><pre><span></span>kubectl<span class="w"> </span>get<span class="w"> </span>secrets<span class="w"> </span>shipa-certificates<span class="w"> </span>-o<span class="w"> </span>json<span class="w"> </span><span class="se">\</span>
<span class="w">        </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="s2">&quot;.data[\&quot;ca.pem\&quot;] |= \&quot;</span><span class="nv">$CA_CERT</span><span class="s2">\&quot;&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">        </span><span class="p">|</span><span class="w"> </span>kubectl<span class="w"> </span>apply<span class="w"> </span>-f<span class="w"> </span>-
</pre></div>
<p><code>jq</code> kann noch viel mehr. Wer das Werkzeug noch nicht kennt sollte unbedingt ein paar Minuten investieren um <a href="https://jqlang.org/tutorial/">das Tutorial</a> querzulesen, und dann bei der nächsten Einsatzmöglichkeit gezielt nach der Syntax schauen. Pro tip: KI's können diese Syntax prima, und <code>jless</code> (kommt gleich) kann diese auch generieren.</p>
<hr>
<h2>jo – JSON in der Shell erzeugen</h2>
<p>Während <code>jq</code> ideal zum Lesen und Transformieren ist, eignet sich <strong><code>jo</code></strong> perfekt, um JSON direkt in der Shell zu erstellen. Damit lassen sich Testdaten oder API-Payloads schnell zusammenbauen.</p>
<p>Ein einfaches Beispiel:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span><span class="nv">name</span><span class="o">=</span>Alice<span class="w"> </span><span class="nv">age</span><span class="o">=</span><span class="m">30</span><span class="w"> </span><span class="nv">active</span><span class="o">=</span><span class="nb">true</span>
</pre></div>
<p>Ausgabe:</p>
<div class="hll"><pre><span></span><span class="p">{</span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="nt">&quot;age&quot;</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="nt">&quot;active&quot;</span><span class="p">:</span><span class="kc">true</span><span class="p">}</span>
</pre></div>
<p>Auch Arrays sind möglich:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span>-a<span class="w"> </span>red<span class="w"> </span>green<span class="w"> </span>blue
</pre></div>
<p>➜ <code>["red","green","blue"]</code></p>
<p>Verschachtelte Objekte:</p>
<div class="hll"><pre><span></span>jo<span class="w"> </span><span class="nv">user</span><span class="o">=</span><span class="k">$(</span>jo<span class="w"> </span><span class="nv">name</span><span class="o">=</span>Alice<span class="w"> </span><span class="nv">id</span><span class="o">=</span><span class="m">42</span><span class="k">)</span><span class="w"> </span><span class="nv">project</span><span class="o">=</span>Demo
</pre></div>
<p>➜ <code>{"user":{"name":"Alice","id":42},"project":"Demo"}</code></p>
<p>Das eignet sich sehr gut für schnelle <code>curl</code>-Requests, aber insbesondere auch für shell scripte in denen inline json sonst sehr schnell sehr unübersichtlich wird:</p>
<div class="hll"><pre><span></span>curl<span class="w"> </span>-X<span class="w"> </span>POST<span class="w"> </span>-H<span class="w"> </span><span class="s2">&quot;Content-Type: application/json&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">     </span>-d<span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>jo<span class="w"> </span><span class="nv">username</span><span class="o">=</span>dev<span class="w"> </span><span class="nv">password</span><span class="o">=</span>secret<span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">     </span>https://example.com/api/login
</pre></div>
<hr>
<h2>yq – YAML lesen und bearbeiten</h2>
<p>YAML verwenden wir überall, am meisten habe ich in Kubernetes damit zu tun. <a href="https://mikefarah.gitbook.io/yq/"><strong><code>yq</code></strong></a> ist das Werkzeug der Wahl, um YAML-Dateien zu lesen, zu durchsuchen und zu editieren. Die Syntax ist sehr nahe an <code>jq</code>, das Werkzeug kann neben YAML aber auch JSON, TOML und XML verarbeiten, und zwischen diesesn Konvertieren. Im wesentlichen kann es das gleiche wie <code>jq</code>, eben auch für YAML.</p>
<hr>
<h2>jless &amp; yless – interaktiv stöbern</h2>
<p>Wenn Dateien zu groß oder zu komplex werden, helfen <a href="https://jless.io"><strong><code>jless</code></strong></a> und <strong><code>yless</code></strong> (ein <code>alias yless=jless --yaml</code>. Sie bieten eine interaktive Ansicht für JSON und YAML – mit:</p>
<ul>
<li>Syntax-Highlighting,</li>
<li>Falten und Aufklappen von Strukturen,</li>
<li>komfortabler Navigation und Suche.</li>
</ul>
<p>Beispiel:</p>
<div class="hll"><pre><span></span>kubectl<span class="w"> </span>get<span class="w"> </span>pods<span class="w"> </span>-oyaml<span class="w"> </span><span class="p">|</span><span class="w"> </span>yless
</pre></div>
<p>Das schöne: Man kann hier auf der Shell wunderbar uninteressante textblöcke einklappen um schnell die wichtigen Informationen zu fokussieren, und dann über Tastaturkommandos werte, oder jq/yq filter auf das aktuell ausgewählte Element kopieren, um das z.B. dann auf alle Pods in einem Namespace anzuwenden.</p>
<hr>
<h2>Fazit</h2>
<p>Mit diesen Tools – <code>jq</code>, <code>jo</code>, <code>yq</code>, <code>jless</code> und <code>yless</code> – wird das Arbeiten mit JSON und YAML auf der Shell <em>deutlich</em> angenehmer. Sehr gut investierte Zeit diese Werkzeuge (eines nach dem Anderen) zu lernen.</p>

    </section>
    
      <footer>
        <a href="blog/2025/8/arbeiten-mit-json-and-yaml-auf-der-shell/">weiterlesen…</a>
      </footer>
    
  </article>

  
    
  <article class="blog-post">
    <header>
      <h2>
        <a href="blog/2025/8/mit-llm-rag-einfach-mal-ausprobieren-direkt-von-der-shell/">
        Mit llm RAG einfach mal ausprobieren – direkt von der Shell
        </a>
      </h2>
      <p class="meta">
        written by Martin Häcker on <time datetime="2025-08-07">Donnerstag, 7. August 2025</time>
      </p>
    </header>

    <section class="blog-post-body">
      <p><img src="blog/2025/8/mit-llm-rag-einfach-mal-ausprobieren-direkt-von-der-shell/workflow.png" alt="Ablaufdiagramm">
Einer der coolsten Aha-Momente der letzten Tage bei mir war, wie einfach und niederschweflig das Arbeiten mit Retrieval-Augmented Generation (RAG) von der Shell inzwischen sein kann – ganz ohne spezielle Infrastruktur, Vektor-Datenbank oder Server-Backend. Das Python-Tool <a href="https://pypi.org/project/llm/"><code>llm</code></a> macht  das möglich: RAG direkt aus der Kommandozeile, mit SQLite als Backend und einfachen Kommandos, die sich hervorragend in Shell-Workflows integrieren lassen.</p>
<h2>Ein Power Tool für Sprachmodelle in der Shell</h2>
<p><a href="https://llm.datasette.io/en/stable/"><code>llm</code> kann natürlich noch viel mehr und ist ein Power Tool, das den Einsatz von KI direkt im Terminal erlaubt</a>. Es erlaubt mit beliebigen API-Providern oder lokalen Modellen zu sprechen und integriert diese damit nahtlos in eigene Skripte. Use Cases: Daten hinein pipen und mit dem LLM bearbeiten. Ob zusammenfassen, erklären, übersetzen, mit einem aufwendigen Prompt aus einer Datei beackern… Da geht so viel. Egal was Ihr aus diesem Artikel mitnehmt, zumindest sollte es sein das Ihr <code>llm</code> in euren Workflow aufnehmt und installiert.</p>
<h2>Der RAG-Workflow von der Shell aus</h2>
<p>Ein kompletter RAG-Workflow funktioniert mit <code>llm</code> in wenigen Schritten. <a href="https://building-with-llms-pycon-2025.readthedocs.io/en/latest/semantic-search-and-rag.html">Diese Demo hier hab ich von Simon Willison geklaut, dem Autor von <code>llm</code></a>. <a href="https://github.com/python/peps">Hier wird semantische Suche in den Python Enhancement Proposals demonstriert</a>. Dieses Tutorial verwendet einen lokalen LLM-Server, man kann das aber natürlich auch mit GitHub Copilot oder ähnlichen Modellen machen. Herauszufinden wie die dort heißen und zu verbinden sind bleibt ein Exercise für den Leser.</p>
<h3>1. Dateien vorbereiten</h3>
<p>Wir erstellen gekürzte Versionen von Textdateien:</p>
<div class="hll"><pre><span></span>mkdir<span class="w"> </span>-p<span class="w"> </span>peps-truncated
<span class="k">for</span><span class="w"> </span>f<span class="w"> </span><span class="k">in</span><span class="w"> </span>peps/*.rst<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span>head<span class="w"> </span>-c<span class="w"> </span><span class="m">8000</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$f</span><span class="s2">&quot;</span><span class="w"> </span>&gt;<span class="w"> </span><span class="s2">&quot;peps-truncated/</span><span class="k">$(</span>basename<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$f</span><span class="s2">&quot;</span><span class="k">)</span><span class="s2">&quot;</span>
<span class="k">done</span>
</pre></div>
<p>Das ist natürlich streng genommen falsch, weil wir ganz viel Daten wegschmeißen. Einiges spricht aber trotzdem dafür:</p>
<ol>
<li>Gerade lokale Modelle haben gerne nicht so große Kontext-Fenster und da muss das Dokument reinpassen.</li>
<li>Meistens steht am Anfang eines Dokuments worum es geht. Für unsere Zwecke also eine gute Näherung.</li>
</ol>
<p>Um das später in ein Produkt umzuwandeln müssten wir uns noch weitere Strategien anschauen, z.B. mit einem Sliding Window über die Dokumente zu gehen und für jeden Abschnitt ein Embedding zu erzeugen. Grundsätzlich ist es aber eine gute Idee verschiedene Indexe zu erzeugen die unterschiedliche Zwecke erfüllen.</p>
<h3>2. Vektor-Index erstellen</h3>
<div class="hll"><pre><span></span>llm<span class="w"> </span>embed-multi<span class="w"> </span>peps<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-m<span class="w"> </span>mxbai-embed-large<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--files<span class="w"> </span>peps-truncated<span class="w"> </span><span class="s1">&#39;pep-3*.rst&#39;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-d<span class="w"> </span>peps.db<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--store
</pre></div>
<p>Das erzeugt eine SQLite-Datenbank mit eingebetteten Vektoren. Wichtig: Die Datenbank speichert auch, mit welchem Modell die Einbettung erfolgte – bei weiteren Operationen auf der gleichen Collection <code>peps</code> ignoriert <code>llm</code> den Modell-Parameter ohne Fehlermeldung!</p>
<p>Seiten-Notiz: Embeddings, was ist das? Ein Embedding ist eine Umwandlung von einem Text in eine Zahlenreihe (Mathematisch: Einen Vektor). Jeder dieser Vektoren beschreibt eine Koordinate in einem Hoch-Dimensionalen Raum, mit der Eigenschaft, das Koordinaten die sich Nahe sind von einem Text kommen der semantisch Ähnlich ist. Darin kann man sogar Rechnen, ein etwas überstrapaziertes Beispiel wäre z.B. der Vektor für König + Weiblich = Königin. <a href="https://simonwillison.net/2023/Oct/23/embeddings/">Mehr gibts hier</a></p>
<h3>3. Abfragen stellen</h3>
<div class="hll"><pre><span></span>llm<span class="w"> </span>similar<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;What do string templates look like?&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>-d<span class="w"> </span>peps.db<span class="w"> </span>-n<span class="w"> </span><span class="m">2</span><span class="w"> </span>peps<span class="w"> </span><span class="se">\</span>
<span class="w">  </span><span class="p">|</span><span class="w"> </span>llm<span class="w"> </span>-s<span class="w"> </span><span class="s2">&quot;Answer the question: What do string templates look like?&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>-m<span class="w"> </span>devstral<span class="w"> </span>-o<span class="w"> </span>num_ctx<span class="w"> </span>256_00
</pre></div>
<p>Hier wird erst ähnliche Inhalte zur Frage gesucht. Wichtige Details: Das Kontext-Fenster des Sprachmodells das antwortet muss groß genug sein, das es alle Antworten in seinen Kontext aufnehmen kann. Ansonsten wird gerne der Anfang abgeschnitten - und da steht natürlich der Treffer mit dem besten Score.</p>
<h3>4. Automatisieren</h3>
<p>Wir können sogar direkt ein Skript generieren lassen:</p>
<div class="hll"><pre><span></span>llm<span class="w"> </span><span class="s1">&#39;</span>
<span class="s1">Build me a bash script like this:</span>
<span class="s1">./pep-qa.sh &quot;What do string templates look like?&quot;</span>
<span class="s1">It should first run:</span>
<span class="s1">llm similar -c $question -d peps.db peps</span>
<span class="s1">Then it should pipe the output from that to:</span>
<span class="s1">llm -s &quot;Answer the question: $question&quot; -m gpt-4.1-mini</span>
<span class="s1">That last command should run so the output is visible as it runs.</span>
<span class="s1">&#39;</span><span class="w"> </span>-x<span class="w"> </span>&gt;<span class="w"> </span>pep-qa.sh
</pre></div>
<h2>Fazit</h2>
<p>Was früher nach viel Setup aussah (Vektor-Datenbank, Backend-API, RAG-Pipeline), ist heute in wenigen Shell-Befehlen machbar. SQLite funktioniert dabei erstaunlich gut – <code>llm</code> führt einfach einen Full-Table-Scan durch und berechnet die Vektor-Abstände direkt. Das ist nicht hyper-skalierbar, aber bis 10.000 bis 100.000 Einträge durchaus brauchbar.</p>
<p>Und das Beste: <code>llm</code> lässt sich überall in bestehende Shell-Skripte und Workflows einbauen – sogar mit piped Input. Wer also mal eben eine intelligente Suche oder ein Sprachmodell in seinen CLI-Workflow integrieren will, findet hier ein extrem mächtiges Toolset.</p>
<p>Ich kann nur empfehlen ein Shell-Werkzeug wie <code>llm</code> zu lernen.</p>

    </section>
    
      <footer>
        <a href="blog/2025/8/mit-llm-rag-einfach-mal-ausprobieren-direkt-von-der-shell/">weiterlesen…</a>
      </footer>
    
  </article>

  
  
  <a href="blog/">Weitere Beiträge…</a>

    </article>
    <footer class="container-fluid ">
      <ul class="nav">
  <li class="nav-item copyright">
    <span class="nav-link">&copy; 2025 <a href="work/">Martin Häcker</a></span>
  </li>
  
    
    <li class="nav-item imprint">
      <a class="nav-link" href="meta/#imprint">
        Impressum
      </a></li>
  
    
    <li class="nav-item privacy-policy">
      <a class="nav-link" href="meta/#privacy-policy">
        Datenschutzerklärung
      </a></li>
  
    
    <li class="nav-item colophon">
      <a class="nav-link" href="meta/#colophon">
        Kolophon
      </a></li>
  
  <li class="ml-auto nav-item rss-feed">
    <a class="nav-link" href="blog/feed.xml">
      <img class="rss-icon" src=/static/rss.svg height=25 width=25>
      <span class="sr-only">RSS-Feed</span>
    </a>
  </li>
  <li class="nav-item license">
    <a class="nav-link" 
      rel="license" 
      target="_blank" 
      href="https://creativecommons.org/licenses/by-sa/4.0/deed.de"
    >
      <img 
        src="/static/cc-by-sa-88x31.png"
        alt="Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 Internationale Lizenz"
      >
    </a>
  </li>
</ul>
    </footer>
  </body>
</html>
